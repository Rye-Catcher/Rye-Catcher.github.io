<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习笔记--几种离散化方式]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在OI学习过程中,我们常常会发现一些题目(尤其数据结构题)中,一些数据的范围很大,但是涉及的数值的个数却很少,同时我们想用一个数组的下标与这些数据建立一一对应关系,这时我们就需要离散化 大致思路 对于一个大小为$N$不含重复数字的数组$a[N] (a[i]&lt;=10^9)$,我们可以将$a[]$中的N个整数与$1$ ~ $N$这$N$构成一一映射关系,也就是说把$a[i]$用一个$1$~$N$中的数字代替,这样空间和时间复杂度都能变成与$N$相关 当然如果数组中有重复数据,你需要先去重(使用$std::unique$等)再进行上述操作 方式 结构体+$sort$ 对于大小为$N$不含重复数据的整型数组$a[N]$,定义结构体 1234struct Data&#123; int x;//原数组中的数据 int id;//原数组中储存x的下标&#125;d[N]; 然后以$x$为关键字进行排序,进行以下操作 1234sort(d+1,d+1+N);//假设从1开始for(int i=1;i&lt;=n;i++)&#123; a[d[i].id]=i;//按大小顺序离散化&#125; 时间复杂度$O(NlogN)$ 空间复杂度$O(N)$ 但是,使用这种方式的前提是数组无重复数据 $sort$+$lower $_$bound$ 这应该是最常见的离散化方式 您只需要知道对于大小为$N$的数组$a[]$, $lower $_$bound(a+1,a+1+N,X)-a$返回$a$中第一个大于等于X的位置 $unique(a+1,a+1+n)-(a+1)$返回将$a$数组去重后$a$的数组大小 然后就不难理解下面代码 123456789for(int i=1;i&lt;=N;i++)&#123;scanf("%d",&amp;a[i]);f[i]=a[i];&#125;sort(f+1,f+1+N);int nn=unique(f+1,f+1+N)-(f+1);//去重for(int i=1;i&lt;=N;i++)&#123;a[i]=lower_bound(f+1,f+1+nn,a[i])-f;&#125; 这样$f[i]$储存了从小到大排序后原来$a$中所有元素,$a[i]$中就储存了按大小排序后,原本$a[i]$大小的排名,$f[ \ a[i] \ ]$则返回原本$a[i]$的值 $map\&amp;unordered $_$map$ 如果您不知道STL中的$map$,建议您先去了解再来看此篇文章 其实思路很$naive$,知道$map$用法的应该都能看懂 12345678910map &lt;int,int&gt; g;int a[N],f[N],tot=0;for(int i=1;i&lt;=N;i++)&#123; scanf("%d",&amp;a[i]); if(!g[a[i]])&#123; g[a[i]]=++tot; f[tot]=a[i]; &#125; a[i]=g[a[i]];&#125; $f[a[i]]$就是原数组$a[i]$的值 但是$map$是用红黑树实现的,储存的元素是有序的 而$unordered $_$map$是用哈希表实现的 而在这里$map$纯粹只是起到了$hash$的查找与赋值,用$unordered\_$map$也能实现,相比较之下一般会更unordered$_$map$快一点(实际上您可以手写一个哈希表完成上面的离散化操作) 然而使用$unordered$_$map$时注意,$C++11$之前使用需要 1234#include &lt;tr1/unordered_map&gt;using namespace std;using namespace std::tr1;unordered_map &lt;int,int&gt;g; $C++ 11$之后则可以使用 123#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int,int&gt;g; $pb $_$ds$中的$hash $_$table$ $pb$ _$ds$中有许多黑科技,您可以在这篇博客中了解: https://blog.csdn.net/Only_AiR/article/details/51940500 其中就有个$hash $_$table$，顾名思义,就是个蛤希表了,可以只用$find()$和$operator[]$,十分方便 然而使用它需要记一点东西,但你问我资不资瓷，当然是资瓷啊 12345#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;cc_hash_table &lt;int,int&gt;g1;//两种hash_table,都跑得和香港记者一样快gp_hash_table &lt;int,int&gt;g2; 后记 话说写这篇博客还是因为这道题 https://www.lydsy.com/JudgeOnline/problem.php?id=4241 我调整各种离散化方式来看看哪个最快,同时在luogu的个人私题中同步测试 然后给大家看看时间比较(因为怕影响大家评测把时间限制开的很小,难免会TLE,$bzoj$时限是80s) $hash $_$table$不知道高到哪里去 然而戏剧性的是BZOJ 上我测出来是$map$最快!!! $18000+ms$ 其余的都比裸$map​$慢了近$1000​$~$2000+​$ $ \ ​$ $ms​$ 很奇怪,BZOJ评测鸭太玄学了,如果有谁知道原因的可以解释下谢谢]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--Tarjan算法之割点与桥]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tarjan%E7%AE%97%E6%B3%95%E4%B9%8B%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[前言 图论中联通性相关问题往往会牵扯到无向图的割点与桥或是下一篇博客会讲的强连通分量,强有力的$Tarjan$算法能在$O(n)$的时间找到割点与桥 定义 若您是第一次了解$Tarjan$算法，建议您反复阅读定义,借助图像来理解 桥与割边 对于无向连通图中点集的一个节点$x$,删去节点$x$及其关联的边之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的割点 对于无向联通图中边集的一条边$e$,删去边$e$之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的桥或割边 对于一般无向图,割点和桥可以指各个联通块的割点和桥 时间戳: 在对图的$DFS$中,按照节点第一次被访问的顺序,给各个节点标记一个值,该值称为时间戳,我们用$dfn[x]$表示$x$的时间戳 搜索树 在对图的$DFS$中,由于每个点只会被搜一次,所以访问经过的边构成了一棵树,称为搜索树,各个节点为根的子树称为$subtree(x)$,注意,$x \in subtree(x)$ 追溯值 这个可以说是$Tarjan$算法的精髓了,在我个人看来,节点$x$的追溯值是指不经搜索树所能到达的所有节点中其时间戳的最小值或者它自身的时间戳. 这看起来很难得到各个节点的追溯值,实则不然,分析一下,节点$x$的追溯值可以在一遍$DFS$中求得,请看下文介绍 算法 性质一: 桥边都是搜索树上的边 反证法,若桥边不是搜索树上的边,断掉这条之后仍可通过搜索树上的边保持图的联通 割边判定法则 无向边$(x,y)$是桥的充要条件是$dfn[x]&lt;low[y]$(假设$y \in subtree(x)$) 让我们想想为什么 $low[y]$表示不经搜索树上的边$y$所能到达的所有节点中其时间戳的最小值,若$dfn[x]&lt;low[y]$,根据定义和性质一,说明只有这条在s搜索树上的边$(x,y)$ ，$y$才能到达$x$,故边$(x,y)$是桥(割边) 割点判定法则 非根点$x$是割点的充要条件是存在一点$y (y \in subtree(x))$,满足$dfn[x]&lt;=low[y]$,类比于上一法则,这里不再赘述 当$x$为根节点时至少要有两个点满足上述条件 大家可以通过图片理解上述过程,粗边都是搜索树上的边 注意 更新$low[x]$ 根据定义,我们只能用$x$在搜索树上儿子的$low[]$值或是一条非搜索树边$(x,y)$中的$dfn[y]$来更新$low[x]$ 重边 在求桥时,若节点$x$与其父亲间有重边,则其中只有一条算搜索树上的边,其他都是非搜索树上的边,可以用来更新. 然而求割点时,由于是点与点联通关系不必考虑重边 代码 桥 1234567891011121314151617181920int dfn[maxn],low[maxn],cnt=0;bool bridge[maxm];void tarjan(int u,int in_edge)&#123;//in_edge--边的编号int v;dfn[u]=low[u]=++cnt;for(ri i=h[u];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[u]=min(low[u],low[v]); if(low[v]&gt;dfn[u])&#123; bridge[i]=bridge[i^1]=1; &#125; &#125; else if(i!=(in_edge^1))&#123; //in_edge^1表示反向边,不是反向边说明是非搜索树边 low[u]=min(low[u],dfn[v]);//通过非树边更新 &#125;&#125;return ;&#125; 割点 123456789101112131415161718192021int dfn[maxn],low[maxn],root,tot=0;bool ans[maxn];void tarjan(int now)&#123;int v,flag=0;dfn[now]=low[now]=++tot;for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[now]=min(low[now],low[v]); if(dfn[now]&lt;=low[v])&#123; flag++; if(now!=root||flag&gt;1)//根节点要有两个满足条件 &#123; if(!ans[now])ans[now]=1;//是割点 &#125; &#125; &#125; else low[now]=min(low[now],dfn[v]);&#125;return ;&#125; 例题 桥+缩点 https://www.luogu.org/problemnew/show/P2860 题解: https://rye-catcher.github.io/2018/07/09/luogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5/ [模板]割点 https://www.luogu.org/problemnew/show/P3388 割点+简单计数 https://www.luogu.org/problemnew/show/P3469 题解:咕咕咕]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2860[USACO冗杂路径]缩点+桥]]></title>
    <url>%2F2018%2F07%2F09%2Fluogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P2860 https://www.lydsy.com/JudgeOnline/problem.php?id=1718 分析首先这题目的意思就是让任意两点之间至少有两条没有重复道路的路径，很显然，如果这个图不存在桥，就一定满足上述条件。 于是我们就是要求使这个图不存在桥需要连接的最小边数 如果把桥从图中去掉，很显然剩余的联通块中任意两点之间至少有两条没有重复道路的路径（当然也可能不是联通块而是孤立的点），对答案不会产生贡献，我们不妨就将这些联通块缩点，于是就原来的图就变成了一颗树。 然后思考题目要求，当每个节点的度为$2$时任意两点之间至少有两条没有重复道路的路径，因为此时任意节点都有两条不同道路可走，于是用贪心的思想我们让度数为$1$的先互相连接，所以计算出树中的叶节点个数$x$，$ \lceil \frac{x}{2} \rceil $就是答案 注意好象没什么注意的，不过我太菜把$edge [j] .to$写成$edge [i] .to$查了好久的错 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#define ll long long #define ri register int using namespace std;const int maxn=5005;const int maxm=10005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxm&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int n,m;int dfn[maxn],low[maxn],tot=0;bool bridge[maxm];void tarjan(int now,int in_edge)&#123;//所在边的标号 int v;dfn[now]=low[now]=++tot; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[now]=min(low[now],low[v]); if(dfn[now]&lt;low[v])&#123; bridge[i]=bridge[i^1]=true;//是桥 bb++; &#125; &#125; else if(i!=(in_edge^1))&#123;//如果不是在同一条无向边的对应边 low[now]=min(low[now],dfn[v]); &#125; &#125; return ;&#125;int num=0;//联通块的数量int in_block[maxn];//各点所在联通块的标号bool g[maxn][maxn];//重构后的图（储存）void Contraction_Point(int now)&#123;//缩点 int v;in_block[now]=num; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!bridge[i]&amp;&amp;!in_block[v])&#123; Contraction_Point(v); &#125; &#125; return ;&#125;int du[maxn];inline void solve()&#123; int ans=0,x,y; memset(g,0,sizeof(g)); for(ri i=1;i&lt;=n;i++)&#123; x=in_block[i]; for(ri j=h[i];j;j=edge[j].ne)&#123; y=in_block[edge[j].to]; //太坑了 g[x][y]=g[y][x]=1; &#125; &#125; memset(du,0,sizeof(du)); for(ri i=1;i&lt;=num;i++)&#123; for(ri j=1;j&lt;=num;j++)&#123; if(i!=j&amp;&amp;g[i][j])&#123;du[j]++; &#125; &#125; &#125; for(ri i=1;i&lt;=num;i++)&#123; if(du[i]==1)ans++; &#125; printf("%d",(int)ceil(ans/double(2))); return ;&#125;int main()&#123; int x,y; read(n),read(m); num_edge=1; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; memset(bridge,0,sizeof(bridge)); tarjan(1,0); memset(in_block,0,sizeof(in_block)); for(ri i=1;i&lt;=n;i++)&#123; if(!in_block[i])&#123; num++; Contraction_Point(i); &#125; &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树上差分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 在做一些树上路径修改&amp;查询相关题目时，有时我们用不着树链剖分，类比于序列上的差分，我们可以进行树上差分，不过情况稍有些不同，分为点值上的差分和边权上的差分两种 点值差分 对树上路径$path(x,y)$进行点值差分方法： $tag[x]++,tag[y]++,tag[lca(x,y)]-=2$ 询问$x$被多少个标记覆盖时进行$dfs$,将$x$所有子树节点$tag[]$之和加上$tag[x]$即使被覆盖数目 例题：https://www.luogu.org/problemnew/show/P3128 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=50005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,k;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int cnt=0;int dep[maxn],fa[maxn],son[maxn],top[maxn],dfn[maxn],rnk[maxn],size[maxn];int sum[maxn];int L,R,dta;void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dep[v]=dep[now]+1,fa[v]=now; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125; void dfs_2(int now,int t)&#123; int v; top[now]=t,dfn[now]=++cnt,rnk[cnt]=now; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;void update_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]--,sum[fa[x]]--; return ;&#125;int ans=-inf;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; ans=max(ans,sum[now]); return ;&#125;int main()&#123; int x,y,z; //double st=clock(); read(n),read(k); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; dep[1]=1,fa[1]=0; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=k;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_lca(x,y); &#125; //double ed=clock(); dfs_3(1); printf("%d\n",ans); //printf("%lf\n",ed-st); return 0;&#125; 边权差分 对树上路径$(x,y)$进行差分方法：（注意$x,y$这里还是节点） $tag[x]++,tag[y]++,tag[lca(x,y)]—,tag[fa[lca(x,y)]]—$ 询问$x$被多少标记覆盖方法同上,然而注意！！ 解决相关问题时不能把$tag[root]$算进贡献，因为它没有后继的边 例题：http://poj.org/problem?id=3417 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=100005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0,n,m;inline void add_edge(int f,int t)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=t; h[f]=num_edge; return ;&#125;int dep[maxn],fa[maxn],size[maxn],dfn[maxn],sum[maxn],son[maxn],top[maxn];void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v; top[now]=t; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125;&#125;int ans;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; //cout&lt;&lt;sum[now]&lt;&lt;endl; if(now!=1&amp;&amp;sum[now]==0)ans+=m; else if(now!=1&amp;&amp;sum[now]==1)ans++; return ;&#125;void update_path(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]-=2; return;&#125;int main()&#123; int x,y,z; read(n),read(m); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; fa[1]=0,dep[1]=1; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_path(x,y); &#125; dfs_3(1); printf("%d\n",ans); return 0;&#125; 例题待填坑 货车运输 天天爱跑步]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树链剖分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 树链剖分是一个很好用的处理树上统计信息的方法,大致思想就是把树上路径分成$log N$条链,再用线段树之类的数据结构维护一下,所以时间复杂度得到了保障 怎么做 个人认为这篇讲的很好: https://www.cnblogs.com/George1994/p/7821357.html 注意几点 debug树链剖分对于我来说真是个痛苦的过程,查了近一个小时错才查出来. 首先你要只要线段树上序列是什么?他们是$dfs_2$中的每个树节点的$dfs$顺序存在$dfn[]$中,$rnk[]$则记录对应$dfn[]$对应的节点编号 build函数123456789101112 void build(int now,int l,int r)&#123;if(l==r)&#123; mx[now]=sum[now]=w[rnk[l]];//注意是rnk[l] return ;&#125;int mid=(l+r)&gt;&gt;1;build(now&lt;&lt;1,l,mid);build(now&lt;&lt;1|1,mid+1,r);sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]);return ; &#125; dfs之前的操作1234 dep[1]=1,fa[1]=1;//假设root是1dfs_1(1);dfs_2(1,1);build(1,1,n); $size[]$子树大小如果初始为1则对子树更新是这样的，若为0则不用-1123read(x),read(z);L=dfn[x],R=dfn[x]+size[x]-1,dta=z;update(1,1,n); 未完待续例题1; https://www.luogu.org/problemnew/show/P2590 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define ri register int #define ll long long using namespace std;const int maxn=30305;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,q,t,w[maxn],dta;int dep[maxn],size[maxn],top[maxn],son[maxn],dfn[maxn],rnk[maxn],fa[maxn],cnt=0;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge;&#125;int sum[maxn&lt;&lt;2],mx[maxn&lt;&lt;2],L,R;/*inline void pushdown(int now,int ln,int rn)&#123; if(tag[now])&#123; sum[now&lt;&lt;1]+=tag[now]*ln; sum[now&lt;&lt;1|1]+=tag[now]*rn; tag[now&lt;&lt;1]+=tag[now]; tag[now&lt;&lt;1|1]+=tag[now]; tag[now]=0; &#125; return ;&#125;*/void build(int now,int l,int r)&#123; if(l==r)&#123; mx[now]=sum[now]=w[rnk[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]); return ;&#125;void update(int now,int l,int r)&#123; if(l==r)&#123; sum[now]=mx[now]=dta; return ; &#125; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(now&lt;&lt;1,l,mid); else update(now&lt;&lt;1|1,mid+1,r); sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]); return ;&#125;int query_mx(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=-inf; if(L&lt;=mid)ans=max(ans,query_mx(now&lt;&lt;1,l,mid)); if(mid&lt;R)ans=max(ans,query_mx(now&lt;&lt;1|1,mid+1,r)); return ans;&#125;int query_sum(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=query_sum(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=query_sum(now&lt;&lt;1|1,mid+1,r); return ans;&#125;void dfs_1(int now)&#123; int v;size[now]=1; //cout&lt;&lt;now&lt;&lt;"-----"&lt;&lt;endl; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v;top[now]=t; dfn[now]=++cnt,rnk[cnt]=now; //cout&lt;&lt;now&lt;&lt;' '&lt;&lt;dfn[now]&lt;&lt;' '&lt;&lt;cnt&lt;&lt;endl; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;void query_path_sum(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); L=dfn[top[x]],R=dfn[x]; ans+=query_sum(1,1,n); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y])swap(x,y); L=dfn[x],R=dfn[y]; ans+=query_sum(1,1,n); printf("%d\n",ans); return ;&#125;void query_path_mx(int x,int y)&#123; int ans=-inf; //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); L=dfn[top[x]],R=dfn[x]; ans=max(ans,query_mx(1,1,n)); x=fa[top[x]]; &#125; //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; if(dfn[x]&gt;dfn[y])swap(x,y); L=dfn[x],R=dfn[y]; //cout&lt;&lt;'-'&lt;&lt;L&lt;&lt;' '&lt;&lt;R&lt;&lt;endl; ans=max(ans,query_mx(1,1,n)); //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; printf("%d\n",ans); return ;&#125;void update_set(int x)&#123; t=dfn[x]; update(1,1,n); return ;&#125;int main()&#123; int x,y; char opt[64]; read(n); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; add_edge(x,y); add_edge(y,x); &#125; for(ri i=1;i&lt;=n;i++)&#123; read(w[i]); dep[i]=fa[i]=son[i]=0; &#125; dep[1]=1,fa[1]=1; dfs_1(1); dfs_2(1,1); build(1,1,n); read(q); while(q--)&#123; scanf("%s",opt); if(opt[0]=='C')&#123; read(x),read(y); dta=y; update_set(x); &#125; else if(opt[1]=='M')&#123; read(x),read(y); //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;'*'&lt;&lt;endl; query_path_mx(x,y); &#125; else &#123; read(x),read(y); query_path_sum(x,y); &#125; &#125; return 0;&#125; 例题2:(待填坑) https://www.luogu.org/problemnew/show/P3384 我比较傻逼现在还不知道为什么只得了30分 练习 简单变式-1 https://www.cnblogs.com/Rye-Catcher/p/9275770.html]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtcoderSoundHound Inc.Contest解题报告]]></title>
    <url>%2F2018%2F07%2F07%2FAtcoderSoundHound-Inc-Contest%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[A C++ Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a+b==15)puts("+"); else if(a*b==15)puts("*"); else puts("x"); return 0;&#125; B C++ Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int maxn=100000;char str[maxn];int main()&#123; int w; scanf("%s",str); scanf("%d",&amp;w); if(w==1)&#123;printf("%s",str);return 0;&#125; for(int i=0;i&lt;strlen(str);i++)&#123; if(i%w==0)&#123; putchar(str[i]); &#125; &#125; return 0;&#125; C 这题画风突变啊喂 这题我比较SB打表没找出规律还是yjw学长点醒了我 $yjw$学长 $orz$ 这题其实是个概率题,长度为$m$,则最多有$m-1$对数字，显然每一对之间是互相不影响的,于是我们先来研究一对数字的情况： 首先每个数字都有n个数字与之配对，总计$n × n$种情况,再考虑对答案做贡献的，假设那一对数字是$x,y (y&gt;x)$,则能做贡献的情况有$n-d$种.当然我们这只是$x&lt;y$的情况，所以共$2×(n-d)$种。当然$d==0$时,就无关大小，只有$(n-d)$种，这需要特判. 然后交上去还是$WA$了,发现强制类型转换写在括号外导致会爆$int$,比较坑 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ri register int using namespace std;template &lt;class T&gt;void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125; int n,m,d;int main()&#123; read(n),read(m),read(d); if(d==0)printf("%.10Lf\n",(long double)(m-1)/n); else if(n&lt;=d)printf("0.0000000\n"); else printf("%.10Lf\n",(long double)(1.00*2*(n-d)*(m-1))/n/n); return 0;&#125; D 这题解法很有意思，比较考验智商 求两个最短路，一个是$s$到$x (x \in [1,n])$的用$yen$衡量的最短路$dis_1(s,x)$,一个是从$t$到$x (x \in [1,n])$的最短路$dis_2(t,x)$,用$snuuk$衡量的最短路 然后我们想，最后$n-1$年出发的时候只用$n$这个点可以交换货币，所以$val[n-1]=dis_1(s,n)+dis_2(t,n)$ 再向下想,在$n-2$年出发时,要么继续到$n$这个点交换货币，要么到$n-1$这个点交换货币，以此类推得到 $val[p]=min(val[p+1],dis_1(s,p)+dis_2(t,p)) p \in [0,n-1]$ 最后初始钱数$-val$值就是对应答案 E 我太菜不知道怎么做，等待咕咕咕的题解吧]]></content>
      <tags>
        <tag>比赛解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误笔记]]></title>
    <url>%2F2018%2F07%2F07%2F%E9%94%99%E8%AF%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[inf值要设大但不要溢出 vis之类的数组使用前都memset一下 memset一些除0外的奇怪的数字时，最好老老实实写for循环（谁叫我脸黑） edge数组不要设小了 C++ 11 不要用register int 手写堆中$heap[]$最好不用结构体，若用，手写swap函数 $bool$ $flag$一定要赋初值！！！！ 树链剖分注意https://www.cnblogs.com/Rye-Catcher/p/9265860.html 边权树上差分注意根节点不能算作贡献]]></content>
      <tags>
        <tag>错误笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APIO2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FAPIO2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0 上了下测试系统，发现居然是毛子的题（貌似系统也是，只给了英文和俄语两个选项），话说T1 A+B什么鬼。 然后向教父请假，教父一脸严肃好吓人，但是我能逃掉期中考hhhhhhhhh 在火车站等车居然看到两个师大的？ Day 1 早上五点多就被吵醒了，到了西客站后等了好久，然后又在宾馆等了好久，然后又背着大包走了好久，然后终于等到了房卡进了房间，话说房间真心不错（然而花的钱也很多） 下午模拟赛在Linux上，然而我$^{tm}$还不会用，VAN蛋，赶紧学了下命令行，自己琢磨GUIDE的字体大小弄了好久。 中午居然组队去吃饭？饭菜好评，按槽位自助打饭好评。接着回宾馆睡了一觉，下午发现可能要迟到了，一路跑过去，然后被一位武汉小哥告知根本没有模拟赛，只是上机？$qwq $ 虚拟机差评，键盘差评，时不时卡顿差评 然后到了实验楼的机房，自装NOI Linux好评，键盘好评，机子速度好评，然而位子这么挤不怕被偷屏吗… 将近五点，在中午食堂等开饭，等了好久被告知在另一个食堂？qwq Day 2 一大早被jyh拉起来到学校旁买本子，结果半天愣是没看到文具店？ 吃完早饭到正志厅准备听课。居然是wuhongxu?!然后一上来先水UOJ群，接着balabala讲起了折纸？！没错，就是折纸，计算机科学中的折纸。PPT全英文差评，看得好费劲，然后基本听不懂orz 然后折纸讲完了，whx比较兴奋地说：“现在我们讲图论中一些有趣的算法”。然而。。。基本听不懂orz,看到APSP(All Pair Shortest Path)各种神仙算法复杂度，和其中一个证明过程，这…orz 接着是秦岳讲课，泊松图像编辑和游戏中的AI，感觉挺有趣的，讲了一堆博弈算法orz 下午终于比较正经，wuvin讲二分，弹幕好评，不过一下就来了什么暴力%之类奇奇怪怪的东西…终于有能听懂的东西了，感动 然后是Kiana(这名字好熟悉啊，好像是哪年的noip还是noi题面中出现过)讲图的匹配…终于有能听懂的东西了，感动……然后讲到了三分图，我：？？？ 后面吃饭领密码条，好象和之前的一模一样 今天也算开拓了视野，JXOI2018 T1 的Gobo sort不是空穴来风，原来真有个叫Bogo sort(猴子排序)的玩意，顺便知晓了后天是PKU的大佬讲课，还知道了那个背着NOI 34th书包的居然是BJ A类队长,而且才初三orz感觉明天要爆0滚粗了… Day 3 上午考试一开始去错了考场真尴尬，居然是在办公楼？！居然还是虚拟机？！然后CCF的工作人员告诉我们只准钦定Linux，用Windows属于作弊（万一不小心按了win键呢） 然后在线看题，还是一样毛子的评测系统，中文翻译好评。T1目测毒瘤数据结构，可以暴力，“小明”是什么鬼？！T2 emmm又是圆，可以暴力 T3 目测图论，可以暴力。 然后我真的只交了暴力，T1，T2第一个Substask，T3第一个$n&lt;=10$的Substask 爆搜 TLE？！最后只得交一个n&lt;=1000 无环的判定，自己想出了一个比较玄学的方法，不知道能不能行。 正当我为我的机智沾沾自喜时，jyh说：不就一个DP.我：…woc好象真的是orz 然后是讲题，T1线段树分治?!什么东西？！T2K-D树？！什么东西？！T3圆方树？！什么东西。 猫锟：“87分的都是暴力没打好” “我翻译的时候就觉得题目太水了，不都是套路嘛” 我：orz 铁牌钦定 Day 4 上午以为8：30吃早饭，结果进入正志厅时老师已经讲课了。话说今天讲课的老师没听过，来的人也更少，是不是一些dalao都去THUPC了…话说我们学校连人都凑不齐… 上午讲数论函数相关，欧拉函数emmm欸我会….杜教筛….有道理 洲阁筛….wtf!? Min_25筛….wtf!? 然后就坐车去八十中，真远啊。 下午听后缀自动机…一下午属于离线状态……顺便打了一下平均边权最大的代码。蒟蒻的我字符串只会Hash(蛤xi) 然后是吃饭，我以为所有窗口饭菜都是一个样…然后就点到最烂的菜…根本没胃口 晚上等到了闭幕式，强行用笔记本为手机续命，一开始先是解释CTSC代码丢失的处理结果，不过对我这种辣鸡没能参加CTSC的选手没影响 然后开始讲APIO，原来这就是APIO的正式考试啊（话说我是不是唯一一个现在才知道的），难怪我这个蒟蒻觉得这么难 “感谢主办方提供实时评测，即时反馈”。。。全场响起了经久不绝的掌声 然后颁奖，中间还有段舞蹈。无疑打铁走人，师大一个高一的拿了Ag，太强了orz 总之第一次参加这样的活动，也学到不少东西，发现自己许多不足：模拟赛基本没打过，临考经验不足，该拿的部分分没拿到，还是要多多努力。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXOI2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FJXOI2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[—Update5.2 成绩出了，见后文 听说省选VAN写游记是传统，本蒟蒻也来发一篇吧。 DAY 0 本来以为省选不在JKFZ举行的结果又是在JKFZ，本校作战感觉终究会是好一些吧，和jyh一起向教父申请停了一天的课，没想到教父居然笑眯眯地答应了，有点出乎意料。 上午和jyh一起打了yjw学长Yali集训时的模拟赛，T1线段树，T2。。。 T3。。。然后愉快地打了线段树，结果。。。爆0。 中午吃完后dalao jyh讲了他T3思路，总之感觉很厉害。 下午dalao jyh写出T3果然是满分，orz。然后被教练拉去和yjw谈一谈赛前经验，然后莫名其妙就变成模拟赛题解讲解，原来T1爆0原因是因为&amp;和|运算不能简单地只是打个标记，我还是naive了。 晚上终于回家了，随便打了下模板，本来想开CSGO，结果偷偷玩了几把混乱大枪战后就睡了。 DAY 1 早上坐车来到JKFZ，打了几遍数论相关模板，连莫比乌斯这种不太会考的都打了一遍。 然而。。。 和jyh一起取考场的时候总是有些奇怪，但还算释然。上机试了下机子，除了键盘有些不适应之外还好没什么问题（一想到NOIP时机子打不开T盘就觉得好笑）。不久题目发了下来。 第一眼看到题面，九条可怜？woc又是吉如一出题。把全部PDF浏览后开始做T1，T1一开始看不懂在草稿纸上推了一遍后却觉得思路还挺容易。 T1大致题面：他先告诉你一个叫gobo sort的排序方法：对于一个成为n的序列a，随机生成另一个长为n序列p，然后构造一个长为n的序列b,使得$b_i$ $=$ $a_{p_i}$。假如这个b是有序的，则停止操作，排序完成，反之不断重复生成p序列的操作. 然后给你一个长为n的序列，和m,l,r。要求你在n长的序列后接上m个值域为[l,r]的数，使得gobo sort中随机生成序列的期望次数最多。 草稿纸上搞了一下发现你只要让每个数字出现的次数平均就好了。具体怎么算这里不再赘述，然而在考场上我发现有几个地方需要注意： 离散化 2.可以用堆维护 3.由于有阶乘，除和取模操作，需要逆元. 然而蛋疼的是我忘了逆元怎么打！！！在考场上手推好久，只得作罢，去做T2 T3 T2打了暴力，T3连暴力都不知道怎么打… 总之出了考场后很颓废，T1没打逆元，什么优化也没加，估计凉凉。 然后下午yjw学长搞来份solution，看了一下T1思路确时没错,T2用sigma推了一大堆结果时间复杂度只有O（r）?T3区间DP，好难根本想不到。 后面看了下逆元，发现原来这么容易求,考场上用费马小定理却没推出来…还是我太弱了。 DAY 懒得数了 五一节后成绩出来了，居然有50分，我想应该是T1 30+T2 20+T3 0瞄了一眼大多都是这个分段，然而我的NOIP只有120，前面都是200+或300+，我还是太蒻了,学长进了A类，不过有一个赣州中学高一省队爷，真的强…以及一位爆0 A队女选手。 然后在知乎上看到这个： 厚颜无耻的出题人 %%% 后记 总之还是意料之中吧，也恰恰反映我的不足，以后还是要多刷题，坚持在NOIP前一月把算法竞赛进阶指南刷完，（现在看怕是没机会了）争取考400+(这么弱怎么可能)。 总之应用一句在其他dalao滚粗记中的话吧： _一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程 。 ——长者_]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F07%2F07%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[Hello World 第一篇博客纪念 $ \mathcal{Enjoy Reading Here} $]]></content>
      <tags>
        <tag>Not Yet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
