<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[luogu1282多米诺骨牌题解--背包DP]]></title>
    <url>%2F2018%2F09%2F09%2Fluogu1282%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%80%A7DP%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P1282 分析题目中给的状态很少,我们先考虑最后能否得到一个值,这样的话我们可以比较容易的想出状态转移方程 用$f[i][j]$表示能否用前$i$张骨牌旋转或不旋转得到上下之差值为$j$，$a[i],b[i]$分别为第$i$张骨牌的上下点数,这样转移方程为 f[i+1][j+a[i+1]-b[i+1]]=f[i+1][j+a[i+1]-b[i+1]] or f[i][j]f[i+1][j+b[i+1]-a[i+1]]=f[i+1][j+b[i+1]-a[i+1]] or f[i][j]​然后根据这个我们就不难想到本题要求的转移方程其实为 f[i+1][j+a[i+1]-b[i+1]]=min(f[i+1][j+a[i+1]-b[i+1]],f[i][j])f[i+1][j+b[i+1]-a[i+1]]=min(f[i+1][j+b[i+1]-a[i+1]],f[i][j]+1)第一个表示不旋转,第二个方程表示旋转的转移 然而这样子可能会得到一个负数怎么办,为了方便起见设$m= \sum_{i=1}^n |a[i]-b[i]|$,然后将$m$视为0这样状态转移就在$[0,2m]$这个范围内了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using std::min;using std::max;using std::abs;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return; &#125;const int maxn=1005;const int max_sum=6006;const int max_dta=5005;const int inf=0x7fffffff-maxn;int f[maxn][max_sum*2],n;int a[maxn],b[maxn];int ans=-inf,m;inline int g(int x)&#123; return x&lt;0?-x:x;&#125;int main()&#123; int x,y,z; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(a[i]),read(b[i]); m+=abs(a[i]-b[i]); &#125; memset(f,0x3f,sizeof(f)); f[1][m+a[1]-b[1]]=0; if(a[1]!=b[1])f[1][m+b[1]-a[1]]=1; for(ri i=1;i&lt;n;i++)&#123; x=a[i+1]-b[i+1],y=b[i+1]-a[i+1]; for(ri j=0;j&lt;=m*2;j++)&#123; if(j+x&gt;=0&amp;&amp;j+x&lt;=m*2)&#123; f[i+1][j+x]=min(f[i+1][j+x],f[i][j]); &#125; if(j+y&gt;=0&amp;&amp;j+y&lt;=m*2)&#123; f[i+1][j+y]=min(f[i+1][j+y],f[i][j]+1); &#125; &#125; &#125; for(ri j=0;j&lt;=m;j++)&#123; if(f[n][m-j]!=0x3f3f3f3f||f[n][m+j]!=0x3f3f3f3f)&#123; printf("%d\n",min(f[n][m-j],f[n][m+j])); return 0; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1356数列的整数性题解--背包DP]]></title>
    <url>%2F2018%2F09%2F09%2Fluogu1356%E6%95%B0%E5%88%97%E7%9A%84%E6%95%B4%E6%95%B0%E6%80%A7%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%80%A7DP%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P1356 分析这道题一个很显然的想法就是$f[i][j]$表示能否利用前$i$个数进行运算得到$j$,但是这意味着你可能需要一个庞大的$bool$数组加上较大的时间复杂度. 于是根据同余的性质我们用$f[i][j]$表示能否利用前$i$个数进行运算得到膜$k$等于$j$的一个数,这样我们只需要一个大小为$f[max_n][max_k]$的数组以及$O(mnk)$的时间复杂度 然而有个问题,就是前面的运算可能得到一个负数,$C++$数组下标是不资瓷负数的,怎么办呢. 我们就用$f[i][j]$表示能否利用前$i$个数进行运算得到绝对值膜$k$等于$j$的一个数,这样就可以方便起见将所有数转化为非负数来处理 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using std::min;using std::abs;using std::max;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=10005;const int inf=0x7fffffff;int f[maxn][105];int a[maxn],cnt=0;int n,k,T;int main()&#123; read(T); while(T--)&#123; read(n),read(k); memset(f,0,sizeof(f)); cnt=0; for(ri i=1;i&lt;=n;i++)&#123; read(a[i]); a[i]=abs(a[i]%k); &#125; f[0][0]=1; for(ri i=1;i&lt;=n;i++)&#123; for(ri j=0;j&lt;=k;j++)&#123; f[i][j]|=f[i-1][(j+a[i])%k]; f[i][j]|=f[i-1][abs(j-a[i])]; //可能有人看到这会有疑惑,就是第一个数不是只可以加吗,这样子岂不是违反题意 //其实以题目所给样例打比方,k=7,a[1]%k=3 //显然f[3]=1,但是按照这代码f[4]也等于1,那是因为-k+3=-4，abs(-4)=4，这种情况在同余 //意义下也需要考虑进去 &#125; &#125; if(f[n][k]||f[n][0])puts("Divisible"); else puts("Not divisible"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2687逢低吸纳题解--线性DP]]></title>
    <url>%2F2018%2F09%2F09%2Fluogu2687%E9%80%A2%E4%BD%8E%E5%90%B8%E7%BA%B3%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%80%A7DP%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P2687 分析题目要求你买最多天数的股票,很容易发现实际上就是求最长下降子序列,但是怎么计算方案数有点烦人 我们用$f[i]$表示以第$i$天结尾的最长下降子序列长度,$g[i]$表示以转移到以第$i$天结尾的最长下降子序列可用的方案数 那么我们可以这样进行状态转移: 12345678910for(ri i=1;i&lt;=n;i++)&#123; for(ri j=0;j&lt;i;j++)&#123; if(c[j]&gt;c[i]&amp;&amp;f[i]==f[j]+1)&#123;//i可以由j转移过来 g[i]+=g[j];//加上转移到j的方案数 &#125; else if(c[i]==c[j]&amp;&amp;f[i]==f[j])&#123;//i与j两者等价,保留i,否则会算重 g[j]=0; &#125; &#125;&#125; 注意最后答案不一定是g[N],因为可能有些不是以第N天结尾的最长下降子序列长度也与答案一样 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define ll double#define ri register int using std::min;using std::max;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=x*10+c-48; x=ne?-x:x;return ;&#125;const int maxn=5005;const int inf=0x7fffffff;int n;ll cnt=0;ll g[maxn];ll c[maxn],f[maxn],ans=-inf;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; scanf("%lf",&amp;c[i]);//read(c[i]); &#125; memset(f,0,sizeof(f)); c[0]=inf; for(ri i=1;i&lt;=n;i++)&#123; for(ri j=0;j&lt;i;j++)&#123; if(c[j]&gt;c[i])&#123; f[i]=max(f[i],f[j]+1); &#125; &#125; ans=max(ans,f[i]); &#125; g[0]=1; for(ri i=1;i&lt;=n;i++)&#123; for(ri j=0;j&lt;i;j++)&#123; if(c[j]&gt;c[i]&amp;&amp;f[i]==f[j]+1)&#123;//i可以由j转移过来 g[i]+=g[j];//加上转移到j的方案数 &#125; else if(c[i]==c[j]&amp;&amp;f[i]==f[j])&#123;//i与j两者等价,保留i g[j]=0; &#125; &#125; //if(f[i]==ans)cnt+=g[i]; //不能加在这里，因为之后g[j]可能为0 &#125; for(ri i=1;i&lt;=n;i++)if(f[i]==ans)cnt+=g[i]; printf("%.0lf %.0lf\n",ans,cnt); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF10D-LCIS题解--线性DP]]></title>
    <url>%2F2018%2F09%2F03%2FCF10D-LCIS%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%80%A7DP%2F</url>
    <content type="text"><![CDATA[题目链接:https://www.luogu.org/problemnew/show/CF10D 方法一分析$LCS​$和$LIS​$已经成烂大街的知识了,可是当这两个合并起来成为$LCIS​$,解决的方式方法也多了起来. 首先有种最朴素的$O(N^4)$方法,$f[i][j]$表示A串第$i$个字母和B串第$j$个字母结尾的状态中$LCIS$的长度,那么 那么如果$a[i]==b[j]$,$f[i][j]=max_{0&lt;=k&lt;j,b[k]&lt;a[i]} (f[i-1][k])+1$ 否则$f[i][j]=f[i-1][j]$ 但是这种方法怎么打印方案呢?我们用$path[j][len[j]]$表示以$j$结尾的$LCIS$方案,$len[j]$指的是以$j$结尾的$LCIS$长度 这样我们从$k$更新到$j$时,首先将$path[k][len[k]]$全部复制到$path[j][len[j]]​$; 然后$len[j]=len[k]+1,path[j][len[j]]=b[j]$ 跑时950+ms 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long #define ri register int using std::max;using std::min;using std::swap;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=505;const int inf=0x7fffffff;int n,m,a[maxn],b[maxn],f[maxn][maxn],len[maxn];int path[maxn][maxn];void print(int x)&#123; for(ri i=1;i&lt;=len[x];i++)printf("%d ",path[x][i]); puts(""); return ;&#125;int main()&#123; int x,y,z; int ans=-inf,ed=0; read(n); for(ri i=1;i&lt;=n;i++)&#123;read(a[i]);&#125; read(m); for(ri i=1;i&lt;=m;i++)&#123;read(b[i]);&#125; a[0]=b[0]=-inf; for(ri i=1;i&lt;=n;i++)&#123; for(ri j=1;j&lt;=m;j++)&#123; if(a[i]==b[j])&#123; for(ri k=0;k&lt;j;k++)&#123; if(b[k]&lt;a[i])&#123; //f[i][j]=max(f[i][j],f[i-1][k]+1); if(f[i][j]&lt;f[i-1][k]+1)&#123; f[i][j]=f[i-1][k]+1; len[j]=len[k]+1; for(ri p=1;p&lt;=len[k];p++)path[j][p]=path[k][p]; &#125; &#125; &#125; &#125; else f[i][j]=f[i-1][j]; //ans=max(ans,f[i][j]); path[j][len[j]]=b[j]; if(ans&lt;f[i][j])&#123; ans=f[i][j]; ed=j; &#125; &#125; &#125; printf("%d\n",ans); print(ed); return 0;&#125; 方法二我们考虑递推时的决策集合,$f[i][j]$都是由$f[i]k$递推得到,那么我们如果在从$f[i][0]$递推到$f[i][j]$时我们已经记录下所有$f[i][k]$的最大值设为$val$,直接将$f[i][j]$设为$max(f[i][j],val+1)$就好了，打印路径的方法跟方法一类似 这样时间复杂度能少个$N$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int #define ull unsigned long long using std::min;using std::max;using std::swap;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=505;const int inf=0x7ffffff;int n,m,a[maxn],b[maxn],f[maxn][maxn],path[maxn][maxn],len[maxn],ed;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(a[i]); &#125; read(m); for(ri i=1;i&lt;=m;i++)&#123; read(b[i]); &#125; int ans=-inf,val,lst=0; for(ri i=1;i&lt;=n;i++)&#123; lst=0; val=f[i-1][0]; for(ri j=1;j&lt;=m;j++)&#123; if(a[i]==b[j])&#123; if(val+1&gt;f[i][j])&#123; f[i][j]=val+1; for(ri k=1;k&lt;=len[lst];k++)path[j][k]=path[lst][k]; len[j]=len[lst]+1; &#125; &#125; else f[i][j]=f[i-1][j]; path[j][len[j]]=b[j]; //ans=max(ans,f[i][j]); if(f[i][j]&gt;ans)&#123; ans=f[i][j]; ed=j; &#125; if(b[j]&lt;a[i])&#123; //val=max(val,f[i-1][j]); if(val&lt;f[i-1][j])&#123; val=f[i-1][j]; lst=j; &#125; &#125; &#125; &#125; printf("%d\n",ans); //printf("%d %d\n",ed,len[ed]); for(ri i=1;i&lt;=len[ed];i++)printf("%d ",path[ed][i]); return 0;&#125; 方法3既然$f[i][j]$是由$f[i-1][k]_{b[k]&lt;b[j]}$转移过来,我们直接用个$f[i]$数组记录,然后每次学习方法2记录决策变量$t$,这样还能满足每个$f[t]$都是上个阶段的. 为什么呢,因为我们的代码已经保证了$a[i]&gt;b[t]$,所以用来更新$j$的$f[t]$不可能在这个阶段中被更新过,所以我们也可以大胆地直接记录路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define ll long long #define ri register int using std::min;using std::max;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=705;const int inf=0x7fffffff;int f[maxn],a[maxn],b[maxn],pre[maxn];int n,m; void print(int x)&#123; if(!x)return ; print(pre[x]); printf("%d ",b[x]); return ;&#125;int main()&#123; int ed=0,t=0; memset(pre,0,sizeof(pre)); read(n); for(ri i=1;i&lt;=n;i++)read(a[i]); read(m); for(ri i=1;i&lt;=m;i++)read(b[i]); f[0]=0; for(ri i=1;i&lt;=n;i++)&#123; t=0; for(ri j=1;j&lt;=m;j++)&#123; if(a[i]==b[j])&#123; f[j]=f[t]+1; pre[j]=t; &#125; if(a[i]&gt;b[j]&amp;&amp;f[j]&gt;f[t])t=j; &#125; &#125; for(ri i=1;i&lt;=m;i++)if(f[ed]&lt;f[i])ed=i; printf("%d\n",f[ed]); print(ed); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2502[HAOI2006]旅行--最小生成树变式]]></title>
    <url>%2F2018%2F09%2F03%2Fluogu%E9%A2%98%E8%A7%A3P2502-HAOI2006-%E6%97%85%E8%A1%8C-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8F%98%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P2502 分析 一个很$naive$的做法是从$s$到$t$双向BFS这当然会TLE 这时我就有个想法就是二分套二分边下标来求得一个比值,同时排序后从小到大枚举每一条边作为最小值,同时再枚举每一条边,如果边权之比小于比值就连起来用并查集维护连通性,可是这个时间复杂度$O(m^2 log^2m \ \alpha(n))$过不去QAQ 然后想为什么不直接枚举每条边作为最小值,同时搞一颗以这条边为最小值且联通s,t的最小生成树呢,因为边是排序好的,这样答案是单调的,且正确性是显然的时间复杂度$O(m^2)$. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long long #define ri register intusing std::sort;using std::min;using std::max;using std::swap;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxm=5005;const int maxn=505;const int inf=0x7fffffff;struct Edge&#123; int x,y,dis; bool operator &lt;(const Edge &amp;b)const&#123; return dis&lt;b.dis; &#125;&#125;edge[maxm];int num_edge=0;int n,m,s,t;int fa[maxn];int get(int x)&#123;return fa[x]==x?fa[x]:(fa[x]=get(fa[x]));&#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;int main()&#123; int x,y,v,xx,yy; bool flag=0; read(n),read(m); for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y),read(v); edge[i].x=x,edge[i].y=y,edge[i].dis=v; &#125; read(s),read(t); sort(edge+1,edge+1+m); int mx,cnt=0; double mi=inf; int fz,fm; for(ri i=1;i&lt;=m;i++)&#123; mx=-inf,flag=0; for(ri j=1;j&lt;=n;j++)fa[j]=j; for(ri j=i;j&lt;=m;j++)&#123; x=edge[j].x,y=edge[j].y,v=edge[j].dis; xx=get(x),yy=get(y); if(xx==yy)continue; fa[xx]=yy; mx=max(mx,v); if(get(s)==get(t))&#123; flag=1;break; &#125;//if(cnt==n-1)break; &#125; if(i==1&amp;&amp;get(s)!=get(t))&#123; puts("IMPOSSIBLE"); return 0; &#125; else if(flag)&#123; double tmp=(double)mx/edge[i].dis; //printf("%d %d %lf\n",mx,edge[i].dis,tmp); if(tmp&lt;mi)&#123; flag=1; mi=tmp; fm=edge[i].dis,fz=mx; &#125; &#125; &#125; int GCD=gcd(fz,fm); fm=fm/GCD,fz=fz/GCD; if(fm==1)printf("%d\n",fz); else printf("%d/%d\n",fz,fm); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>变式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA571Jugs题解--数论(其实是乱搞)]]></title>
    <url>%2F2018%2F08%2F27%2FUVA571Jugs%E9%A2%98%E8%A7%A3-%E6%95%B0%E8%AE%BA-%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B9%B1%E6%90%9E%2F</url>
    <content type="text"><![CDATA[题目链接https://cn.vjudge.net/problem/UVA-571 分析刚做了道倒水问题的题想看看能不能水二倍经验,结果发现了这道题 题意翻译:https://www.cnblogs.com/devymex/archive/2010/08/04/1792288.html 设A容量$x$,B容量$y$ 我们把将水倒入A视为$+x$,将倒空B视为$-y$,若A满,就倒入B视为$-x$ 由于$a,b$是互质的,根据裴蜀定理一定有$x,y$保证有$ax+by=gcd(a,b)=1$,又因为$y&gt;=c&gt;=x&gt;=0$那么也就保证了一定存在非负整数$x$和一个整数$y$使得$ax+by=c$. 于是一开始我的思路是运用扩展$GCD$求出一组解后将$x$转化为一个非负数解.然后按步骤模拟就好了 然而在我写模拟步骤时忽然发现完全不用扩欧啊,我们的模拟过程其实就是: 若A空,则将A倒满 若B满,将B倒空 若A满,将A中水倒入B中 由于题目要求输出一种解就好了于是我们直接模拟就好了,至于为什么会这样,我好像还找不到较为严谨的数学证明 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define ll long long #define ri register intusing std::min;using std::max;using std::swap;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;int ex_gcd(int a,int b,int x,int y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; int d=ex_gcd(b,a%b,x,y); int z=x;x=y,y=z-(a/b)*y; return d;&#125;int a,b,c;int main()&#123; int x,y,lef; int bot[3]; while(scanf("%d %d %d",&amp;a,&amp;b,&amp;c)!=EOF)&#123; //int d=ex_gcd(a,b,x,y); bool flag=1; if(b==c)&#123; puts("fill B"); puts("success"); flag=0; &#125; bot[1]=bot[2]=0; //if(x&gt;0)&#123; while(1&amp;&amp;flag)&#123; if(bot[2]==c)&#123; puts("success"); break; &#125; if(!bot[1])&#123; bot[1]=a; puts("fill A"); &#125; else if(bot[2]==b)&#123; puts("empty B"); bot[2]=0; &#125; else if(bot[1])&#123; lef=b-bot[2]; if(lef&lt;bot[1])&#123; bot[1]-=lef; bot[2]+=lef; &#125; else &#123; bot[2]+=bot[1]; bot[1]=0; &#125; puts("pour A B"); &#125; //printf("%d %d\n",bot[1],bot[2]); //system("PAUSE"); &#125; //&#125; /*else&#123; int k=(-c*x)/b+1; x=c*x+k*b,y=c*y-k*a; &#125;*/ &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>乱搞</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA10603Fill题解--BFS]]></title>
    <url>%2F2018%2F08%2F27%2FUVA10603Fill%E9%A2%98%E8%A7%A3-BFS%2F</url>
    <content type="text"><![CDATA[题目链接https://cn.vjudge.net/problem/UVA-10603 分析经典的倒水问题,直接BFS. 对于喜闻乐见的状态判重,一开始想来个哈希函数把一个三元组映射成一个数，后面发现数据很小直接三维数组，后面又发现总水量是固定值,直接二维$bool$数组就好了 然后每次取出状态更新下答案,搜索时就是枚举将哪个杯子的水倒入哪个杯子还是很好写的，记得要状态还原 忽然发现最近只会写写水题过活了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define ll long long #define ri register int #define ull unsigned long long using std::priority_queue;using std::min;using std::swap;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=205;const int inf=0x7fffffff;int ans=inf,step=0;int a,b,c,d;struct Sta&#123; int bot[3]; int sum; Sta()&#123;bot[0]=bot[1]=bot[2]=sum=0;&#125; Sta(int _x,int _y,int _z,int _sum)&#123;bot[0]=_x,bot[1]=_y,bot[2]=_z,sum=_sum;&#125; inline bool update()&#123; for(ri i=0;i&lt;3;i++)&#123; if(bot[i]&gt;d)continue; if(ans&gt;d-bot[i])&#123; ans=d-bot[i]; step=sum; &#125; &#125; if(!ans)return 1; return 0; &#125; bool operator &lt;(const Sta &amp;b)const&#123; return sum&gt;b.sum; &#125;&#125;Tmp;bool vis[205][205];int size[3],now[3];int t;inline void bfs()&#123; memset(vis,0,sizeof(vis)); ans=inf,step=0; priority_queue &lt;Sta&gt; q; while(q.size())q.pop(); q.push(Sta(0,0,c,0)); vis[0][0]=1; int x,y,z,lef,o,p; while(q.size())&#123; Tmp=q.top();q.pop(); if(Tmp.update())&#123; printf("%d %d\n",Tmp.sum,d-ans); return ; &#125; now[0]=Tmp.bot[0],now[1]=Tmp.bot[1],now[2]=Tmp.bot[2],o=Tmp.sum; for(ri i=0;i&lt;3;i++)&#123;//i倒入j杯 for(ri j=0;j&lt;3;j++)&#123; if(!now[i]||size[j]==now[j]||i==j)continue; lef=size[j]-now[j]; if(now[i]&gt;=lef)&#123; now[i]-=lef; now[j]=size[j]; if(!vis[now[0]][now[1]])&#123; vis[now[0]][now[1]]=1; q.push(Sta(now[0],now[1],now[2],o+lef)); &#125; now[i]+=lef; now[j]-=lef; &#125; else&#123; p=now[i]; now[i]=0; now[j]+=p; if(!vis[now[0]][now[1]])&#123; vis[now[0]][now[1]]=1; q.push(Sta(now[0],now[1],now[2],o+p)); &#125; now[i]=p; now[j]-=p; &#125; &#125; &#125; &#125; printf("%d %d\n",step,d-ans); return ;&#125;int main()&#123; read(t); while(t--)&#123; read(a),read(b),read(c),read(d); size[0]=a,size[1]=b,size[2]=c; bfs(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P1032字串变换--string骚操作]]></title>
    <url>%2F2018%2F08%2F27%2Fluogu%E9%A2%98%E8%A7%A3P1032%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2-string%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P1032 分析这题本来很裸的一个BFS，发现其中的字符串操作好烦啊。然后就翻大佬题解发现用STL中的string居然变得这么简洁！！！ 各种string操作请看另一位大佬博客，写得很全啊： https://www.cnblogs.com/rvalue/p/7327293.html#commentform 其实我们这题只用到两个相关函数:$S.find(string,pos)$和$S.substr()$ 前一个是朴素查找,后一个是子串替换，用法都在那个大佬博客中有 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;#define ll long long #define ri register int#define mkp make_pairusing namespace std;using namespace __gnu_pbds;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=25;const int inf=0x7fffffff;pair&lt;string,string&gt; pi[maxn],TMP;int ans=0,cnt=0;gp_hash_table &lt;string,bool&gt; g;string A,B;struct Dat&#123; string p; int step; Dat()&#123;;&#125; Dat(string _p,int _s)&#123;p=_p;step=_s;&#125;&#125;Tmp;queue&lt; Dat &gt; q;int main()&#123; string a,b; int t,pos; std::ios_base::sync_with_stdio(0); cin.tie(0); cin&gt;&gt;A&gt;&gt;B; while(cin&gt;&gt;a&gt;&gt;b)&#123; pi[++cnt]=mkp(a,b); &#125; q.push(Dat(A,0)); g[A]=1; while(q.size())&#123; Tmp=q.front(); A=Tmp.p,t=Tmp.step;q.pop(); if(A==B)&#123; ans=t; if(t&lt;10)&#123;printf("%d\n",t);&#125; else puts("NO ANSWER"); return 0;//break; &#125; for(ri i=1;i&lt;=cnt;i++)&#123; a=pi[i].first; pos=A.find(a);//返回查找串开头位置 while(pos!=A.npos)&#123; b=A.substr(0,pos);//将前部分串复制下来 b+=pi[i].second;//拼接串 b+=A.substr(pos+a.size());//将后面的串接上去 if(!g[b])&#123; q.push(Dat(b,t+1)); g[b]=1; &#125; pos=A.find(a,pos+1); &#125; &#125; &#125; puts("NO ANSWER"); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BFS</tag>
        <tag>C++ STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3085NightmareII题解--双向BFS]]></title>
    <url>%2F2018%2F08%2F27%2FHDU3085NightmareII%E9%A2%98%E8%A7%A3-%E5%8F%8C%E5%90%91BFS%2F</url>
    <content type="text"><![CDATA[题目链接http://acm.hdu.edu.cn/showproblem.php?pid=3085 分析大意就是一个男孩和一个女孩在网格里,同时还有两个鬼,男孩每轮走三步，女孩每轮走一步，与鬼曼哈顿距离不超过2*轮数的区域都被鬼占领，问男孩女孩最少多少轮相遇？ 这题显然用双向BFS,男孩每轮拓展3次,女孩每轮拓展1次,一个记录女孩走过哪些地方，另一个记录男孩，有个地方被两人都走过就输出答案 然后一开始我就发现我的BFS写得代码又臭又长,后面看一位大佬博客才学到简洁的操作 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#define ll long long #define ri register intusing std::min;using std::max;using std::swap; using std::queue;template &lt;class T&gt;inline int abs(int x)&#123; return x&lt;0?-x:x;&#125;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=805;const int inf=0x7fffffff;const int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;int g[maxn][maxn];int n,m,T;int sx,sy,tx,ty;int gx1,gx2,gy1,gy2;char str[maxn];struct Dat&#123; int x,y; Dat (int _x,int _y)&#123;x=_x,y=_y;&#125; Dat () &#123;x=y=0;&#125;&#125;;int cnt=1,dis;bool wtf=0;bool vis1[maxn][maxn],vis2[maxn][maxn];bool check(int x,int y)&#123; //if(wtf)printf("** %d %d %d %d %d %d\n",x,y,cnt,dis,abs(x-gx1)+abs(y-gy1),abs(x-gx2)+abs(y-gy2)); if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m&amp;&amp;g[x][y]!=1&amp;&amp;(abs(x-gx1)+abs(y-gy1))&gt;dis&amp;&amp;(abs(x-gx2)+abs(y-gy2))&gt;dis)return 1; return 0;&#125;inline void bfs()&#123; int x,y,xx,yy; int x1,x2,x3,y1,y2,y3,x4,y4; queue &lt;Dat&gt; q1,q2; while(q1.size())q1.pop(); while(q2.size())q2.pop(); q1.push(Dat(sx,sy)); q2.push(Dat(tx,ty)); cnt=1,dis=2; int l1=1,r1=1,l2=1,r2=1,lst=0; memset(vis1,0,sizeof(vis1)); memset(vis2,0,sizeof(vis2)); vis1[sx][sy]=vis2[tx][ty]=1; while(q1.size()&amp;&amp;q2.size())&#123;wtf=0; for(ri k=1;k&lt;=3;k++)&#123; lst=r1; while(l1&lt;=lst)&#123; x=q1.front().x,y=q1.front().y;q1.pop(); l1++; if(!check(x,y))continue; //printf("1 %d %d\n",x,y); for(ri i=0;i&lt;4;i++)&#123; xx=x+dx[i],yy=y+dy[i]; if(!check(xx,yy)||vis1[xx][yy])continue; q1.push(Dat(xx,yy)); if(vis2[xx][yy])&#123; //printf("--%d %d %d\n",cnt,xx,yy); printf("%d\n",cnt); return ; &#125; vis1[xx][yy]=1; r1++; &#125; &#125; &#125; lst=r2;wtf=1; while(l2&lt;=lst)&#123; x=q2.front().x,y=q2.front().y;q2.pop();//printf("%d %d\n",l2,lst); l2++; if(!check(x,y))continue; for(ri i=0;i&lt;4;i++)&#123; xx=x+dx[i],yy=y+dy[i]; if(!check(xx,yy)||vis2[xx][yy])continue; q2.push(Dat(xx,yy));//printf("2 %d %d\n",xx,yy); if(vis1[xx][yy])&#123; printf("%d\n",cnt); return ; &#125; vis2[xx][yy]=1; r2++; &#125; //printf("*** %d %d %d\n",l2,r2,lst); &#125; cnt++; dis=cnt*2; &#125; puts("-1"); return ;&#125;int main()&#123; read(T); while(T--)&#123; read(n),read(m); gx1=gy1=inf; for(ri i=1;i&lt;=n;i++)&#123; scanf("%s",str+1); for(ri j=1;j&lt;=m;j++)&#123; vis1[i][j]=0,vis2[i][j]=0; if(str[j]=='.')g[i][j]=0; else if(str[j]=='X')g[i][j]=1; else if(str[j]=='M')&#123; g[i][j]=2; sx=i,sy=j; &#125; else if(str[j]=='G')&#123; g[i][j]=3; tx=i,ty=j; &#125; else if(str[j]=='Z')&#123; if(gx1==inf)gx1=i,gy1=j; else gx2=i,gy2=j; &#125; &#125; &#125; //printf("%d %d %d %d %d %d %d %d\n",sx,sy,tx,ty,gx1,gy1,gx2,gy2); bfs(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--八数码问题]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学习笔记—八数码问题先看道题目https://www.luogu.org/problemnew/show/P1379 分析经典的八数码问题,有双向BFS和$IDA$ 的方法，这里使用的是$A$ 启发式搜索. 简要介绍一下$A$ ,就是对于搜索的每一个状态设计一个评估函数$f(state)$,表示当前状态$state$到目标状态所需代价的估计值;还有一个$g(state)$,表示当前状态$state$到目标状态实际需要的最小代价,$A$ 中必须保证$f(state)&lt;=g(state)$才能确保在目标状态第一次被取出时就是最优解（实际一点,比如最少的步数）并且在搜索中每个状态只需扩展一次，设计的估价函数$f(stste)$越接近$g(state)$效率越高. 我们这里用曼哈顿距离设计估价函数，也就是$f(state)=\sum^9_{i=1} (|posx_i-goalx_i|+|posy_i-goaly_i|) $ $posx_i$表示$i$这个数字在九宫格中的横坐标,$posy_i$也就类似的。注意,我们不能统计$0$，否则这样$f(state)$可能会大于实际代价 为了确保每个状态都被拓展一次，我们可以采用康托展开(将$1-n$的全排列映射成$1-n!$中的一个数)或是哈希表(unordered_map/pb_ds::gp_hash_table/map) 同时还要注意,八数码问题有时候是没有解的,我们将九宫格除空格之外的数按从左到右,再从上到下的顺序排成一列数来表示每一个状态，如果初始状态和目标状态的逆序对个数奇偶性不同的话是无解的,可以提前判断一下是否有解来提高效率 题目:P1379 八数码难题题目链接：https://www.luogu.org/problemnew/show/P1379 非常简单,甚至不用判断无解 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;cmath&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;#define ll long long #define ri register int #define ull unsigned long long using std::pair;using std::swap;using std::abs;using std::priority_queue;using namespace __gnu_pbds;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=5;const int inf=0x7fffffff;const int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;;int sta[maxn][maxn];ll st,goal;gp_hash_table &lt;ll,bool&gt;g;pair&lt;int,int&gt;pos[10];struct Sta&#123; ll a; int s,f; Sta()&#123;;&#125; Sta(ll _a,int _s,int _f)&#123;a=_a,s=_s,f=_f;&#125; bool operator &lt;(const Sta &amp;b)const&#123; return f&gt;b.f; &#125;&#125;;int bx,by;//0位置 inline int get_f()&#123;//估价函数 int ans=0; for(ri i=1;i&lt;=3;i++)&#123; for(ri j=1;j&lt;=3;j++)&#123; ans+=abs(i-pos[sta[i][j]].first)+abs(j-pos[sta[i][j]].second); &#125; &#125; return ans;&#125;inline ll turn_num()&#123;//转为数字 ll ans=0; for(ri i=1;i&lt;=3;i++)&#123; for(ri j=1;j&lt;=3;j++)&#123; ans=ans*10+sta[i][j]; &#125; &#125; return ans;&#125;inline void turn_sta(ll num)&#123;//转为九宫格 for(ri i=3;i&gt;=1;i--)&#123; for(ri j=3;j&gt;=1;j--)&#123; sta[i][j]=num%10; num=num/10; if(!sta[i][j])bx=i,by=j; &#125; &#125; return ;&#125;inline void astar()&#123; ll now,nxt; int x,y,z; Sta tmp; priority_queue&lt;Sta&gt;q; while(q.size())q.pop(); turn_sta(st); q.push(Sta(st,0,get_f())); g[st]=1; while(q.size())&#123; tmp=q.top();q.pop(); now=tmp.a,z=tmp.s; if(now==goal)&#123; printf("%d\n",z); return ; &#125; turn_sta(now); for(ri i=0;i&lt;4;i++)&#123; x=bx+dx[i],y=by+dy[i]; if(x&gt;=1&amp;&amp;x&lt;=3&amp;&amp;y&gt;=1&amp;&amp;y&lt;=3)&#123; swap(sta[bx][by],sta[x][y]); nxt=turn_num(); if(g[nxt])&#123; swap(sta[bx][by],sta[x][y]); continue; &#125; g[nxt]=1; q.push(Sta(nxt,z+1,z+1+get_f())); swap(sta[bx][by],sta[x][y]); &#125; &#125; &#125; puts("unsolvable"); return ;&#125;int main()&#123; /*230187546*/ int x,y,z; pos[0].first=2,pos[0].second=2; pos[1].first=1,pos[1].second=1; pos[2].first=1,pos[2].second=2; pos[3].first=1,pos[3].second=3; pos[4].first=2,pos[4].second=3; pos[5].first=3,pos[5].second=3; pos[6].first=3,pos[6].second=2; pos[7].first=3,pos[7].second=1; pos[8].first=2,pos[8].second=1; read(st); goal=123804765; astar(); return 0;&#125; POJ1077 Eight题目链接:http://poj.org/problem?id=1077 要打印方案,我用了一个$naive$的方法,就是记录每个状态是从哪个状态转移过来的($A*$保证扩展到每一个状态时一定是花费最少的步数)，同时再用一个哈希表记录它是进行哪个操作转移过来的，最后递归打印即可 当然还有其他方法这里不赘述.由于POJ好像不资瓷pbds和unordered_map,只好用map 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;cmath&gt;#include &lt;map&gt; #define ll long long #define ri register int #define ull unsigned long long using namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=5;const int inf=0x7fffffff;const int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;;const char ch[4]=&#123;'u','l','r','d'&#125;;int sta[maxn][maxn];ll st,goal;map &lt;ll,ll&gt; pre;map &lt;ll,int&gt; dir;pair&lt;int,int&gt;pos[10];struct Sta&#123; ll a; int s,f; Sta()&#123;;&#125; Sta(ll _a,int _s,int _f)&#123;a=_a,s=_s,f=_f;&#125; bool operator &lt;(const Sta &amp;b)const&#123; return f&gt;b.f; &#125;&#125;;int bx,by;//0位置 inline int get_f()&#123; int ans=0; for(ri i=1;i&lt;=3;i++)&#123; for(ri j=1;j&lt;=3;j++)&#123; if(sta[i][j]==0)continue; ans+=abs(i-pos[sta[i][j]].first)+abs(j-pos[sta[i][j]].second); &#125; &#125; return ans;&#125;inline ll turn_num()&#123; ll ans=0; for(ri i=1;i&lt;=3;i++)&#123; for(ri j=1;j&lt;=3;j++)&#123; ans=ans*10+sta[i][j]; &#125; &#125; return ans;&#125;inline void turn_sta(ll num)&#123; for(ri i=3;i&gt;=1;i--)&#123; for(ri j=3;j&gt;=1;j--)&#123; sta[i][j]=num%10; num=num/10; if(!sta[i][j])bx=i,by=j; &#125; &#125; return ;&#125;void print(ll x)&#123; /*234150768*/ if(x==st)return ; print(pre[x]); putchar(ch[dir[x]]); return ;&#125;inline void astar()&#123; ll now,nxt; int x,y,z; Sta tmp; priority_queue&lt;Sta&gt;q; while(q.size())q.pop();//puts("wtf"); turn_sta(st); q.push(Sta(st,0,get_f())); while(q.size())&#123; tmp=q.top();q.pop(); now=tmp.a,z=tmp.s; if(now==goal)&#123; //printf("%d\n",z); //printf("%lld***\n***",pre[st]); print(goal); return ; &#125; //printf("*%lld\n",now); turn_sta(now); for(ri i=0;i&lt;4;i++)&#123; x=bx+dx[i],y=by+dy[i]; if(x&gt;=1&amp;&amp;x&lt;=3&amp;&amp;y&gt;=1&amp;&amp;y&lt;=3)&#123; swap(sta[bx][by],sta[x][y]); nxt=turn_num(); if(!pre[nxt])&#123; pre[nxt]=now; dir[nxt]=i; q.push(Sta(nxt,z+1,z+1+get_f())); &#125; swap(sta[bx][by],sta[x][y]); &#125; &#125; &#125; puts("unsolvable"); return ;&#125;int main()&#123; int num[10]; char x[2]; pos[0].first=3,pos[0].second=3; pos[1].first=1,pos[1].second=1; pos[2].first=1,pos[2].second=2; pos[3].first=1,pos[3].second=3; pos[4].first=2,pos[4].second=1; pos[5].first=2,pos[5].second=2; pos[6].first=2,pos[6].second=3; pos[7].first=3,pos[7].second=1; pos[8].first=3,pos[8].second=2; //read(st); st=0; for(ri i=1;i&lt;=9;i++)&#123; scanf("%s",x); if(x[0]=='x')st=st*10,num[i]=inf; else st=st*10+x[0]-'0',num[i]=x[0]-'0'; &#125; //printf("%lld\n",st); int cnt=0; for(ri i=1;i&lt;=9;i++)&#123; if(num[i]==inf)continue; for(ri j=i+1;j&lt;=9;j++)&#123; if(num[j]&lt;num[i])&#123;cnt++;&#125; &#125; &#125; //printf("%d\n",cnt); if(cnt%2==1)&#123; puts("unsolvable"); &#125; else&#123; pre[st]=19260817; goal=123456780; astar(); &#125; return 0;&#125; UVA652 Eight题目链接: https://cn.vjudge.net/problem/UVA-652 这道题由于多组数据发现各个$A*$好像不太行,于是就先一遍BFS扩展出所有状态同时记录路径,这一次没用哈希表用了康拓展开，然而不知道为何WA掉了。。。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;iostream&gt;#define ll long long #define ri register int #define ull unsigned long long using namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=5;const int inf=0x7fffffff;const int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;;const char ch[4]=&#123;'u','l','r','d'&#125;;const int fac[10]=&#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int sta[maxn][maxn];ll st,goal;struct Sta&#123; ll a;int v; Sta()&#123;;&#125; Sta(ll _a,int _v)&#123;a=_a,v=_v;&#125;&#125;;int bx,by;//0位置 int num[10],len[500005];char path[500005][75];inline ll turn_num()&#123; ll ans=0; for(ri i=1;i&lt;=3;i++)&#123; for(ri j=1;j&lt;=3;j++)&#123; ans=ans*10+sta[i][j]; num[(i-1)*3+j]=sta[i][j]; &#125; &#125; return ans;&#125;inline int cal_cantor()&#123; int sml=0,x=0; for(ri i=1;i&lt;=9;i++)&#123; sml=0; for(ri j=i+1;j&lt;=9;j++)&#123; if(num[j]&lt;num[i])++sml; &#125; x+=fac[9-i]*sml; &#125; return x+1;&#125; inline void turn_sta(ll p)&#123; for(ri i=3;i&gt;=1;i--)&#123; for(ri j=3;j&gt;=1;j--)&#123; sta[i][j]=p%10; p=p/10; if(sta[i][j]==9)bx=i,by=j; &#125; &#125; return ;&#125;bool vis[500005];inline void bfs()&#123; ll now,nxt; int x,y,z,pre_val,val; Sta tmp; queue&lt;Sta&gt;q; while(q.size())q.pop();//puts("wtf"); turn_sta(goal); z=turn_num(); val=cal_cantor(); vis[val]=1; q.push(Sta(goal,val)); while(q.size())&#123; tmp=q.front();q.pop(); now=tmp.a,pre_val=tmp.v; turn_sta(now); for(ri k=0;k&lt;4;k++)&#123; x=bx+dx[k],y=by+dy[k]; if(x&gt;=1&amp;&amp;x&lt;=3&amp;&amp;y&gt;=1&amp;&amp;y&lt;=3)&#123; swap(sta[bx][by],sta[x][y]); nxt=turn_num(); val=cal_cantor(); //printf("%d %d %lld %d %d\n",x,y,nxt,val,pre_val); if(!vis[val])&#123; vis[val]=1; for(ri i=1;i&lt;=len[pre_val];i++)&#123; path[val][i]=path[pre_val][i]; &#125; len[val]=len[pre_val]; path[val][++len[val]]=ch[k]; q.push(Sta(nxt,val)); &#125; swap(sta[bx][by],sta[x][y]); &#125; &#125; &#125; return ;&#125;int main()&#123; /*234150768*/ /*123456780*/ /* 2 2 3 4 1 5 x 7 6 8 2 3 4 1 5 x 7 6 8 */ std::ios_base::sync_with_stdio(0); cin.tie(NULL); int t,val; char kkk; read(t); goal=123456789; memset(vis,0,sizeof(vis)); bfs(); while(t--)&#123; st=0; for(ri i=1;i&lt;=9;i++)&#123; cin&gt;&gt;kkk;//scanf("%s",x); if(kkk=='x')st=st*10,num[i]=9; else st=st*10+kkk-'0',num[i]=kkk-'0'; &#125; val=cal_cantor(); //printf("%d %d\n",val,len[val]); if(!vis[val])&#123; puts("unsolvable"); &#125; else&#123; for(ri i=len[val];i&gt;=1;i--)putchar(path[val][i]); puts(""); &#125; if(t)puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BFS</tag>
        <tag>学习笔记</tag>
        <tag>A*/IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI17普及23-B.星空题解--图的灵活转化]]></title>
    <url>%2F2018%2F08%2F11%2FZROI17%E6%99%AE%E5%8F%8A23-B-%E6%98%9F%E7%A9%BA%E9%A2%98%E8%A7%A3-%E5%9B%BE%E7%9A%84%E7%81%B5%E6%B4%BB%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目链接版权原因不予提供 分析这题思路很妙啊,虽然已经算半个套路题（因为我太菜了） 将框视为点,若一个球能放在$x$或$y$框,则$x,y$连一条无向边。有一条非常显然的性质是:在联通块中,若有奇数条边,则经过一定能调整使得最少有一个答案贡献,若有奇数条边,则最少对答案没有贡献 这个性质其实非常好想,但我想了挺久找不出合适的话来解释，标程用图来解释就比较直观更好处理 于是我们只要模拟上述过程就好了,一道看似与图无关的题用图就迎刃而解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define ll long long #define ri register int #define ull unsigned long longusing namespace std; template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=200005;const int inf=0x7fffffff;int n,m;int fa[maxn],num[maxn];int get(int x)&#123;return (x==fa[x])?fa[x]:(fa[x]=get(fa[x]));&#125;int main()&#123; int x,y; srand(19260817);//闷声发大财 预祝长者大寿 Long Live Jiang !!! read(n),read(m); for(ri i=1;i&lt;=m;i++)fa[i]=i; for(ri i=1;i&lt;=n;i++)&#123; read(x),read(y); x=get(x),y=get(y); if(x==y)num[x]++; else &#123; fa[x]=y; num[y]=num[y]+num[x]+1; &#125; &#125; ll ans=0; for(ri i=1;i&lt;=m;i++)&#123; if(i==fa[i])ans+=(num[i]%2); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI17普及23-A.如烟题解--技巧枚举]]></title>
    <url>%2F2018%2F08%2F11%2FZROI17%E6%99%AE%E5%8F%8A23-A-%E5%A6%82%E7%83%9F%E9%A2%98%E8%A7%A3-%E6%8A%80%E5%B7%A7%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[题目链接因版权原因不予提供 分析别看这是普及模拟赛,其实基本上是提高难度…像这题做NOIpT1的话也说的过去 有个很显然的暴力思路就是枚举c,a,b,时间复杂度$O(N^3)$， 然后正解其实就是改变枚举顺序,我们先枚举a点,然后将所有可作为c点的点存起来,再从那些c点遍历得到可行b点统计答案,这样就不会重复且符合题意 不过这道题需要仔细读题，像我这种菜B一开始就理解错题意了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define ll long long #define ri register int #define ull unsigned long longusing namespace std; template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=3005;const int inf=0x7fffffff;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1],_edge[maxn&lt;&lt;1];int h[maxn],num_edge=1;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge;&#125;int _h[maxn],_num_edge=1;//反向边 inline void _add_edge(int f,int to)&#123; _edge[++_num_edge].ne=_h[f]; _edge[_num_edge].to=to; _h[f]=_num_edge;&#125;int n,m,sc,sb;bool vis[maxn];vector &lt;int&gt; g;void _dfs(int now,int fa)&#123; int v;if(vis[now])return ; vis[now]=1;g.push_back(now); for(ri i=_h[now];i;i=_edge[i].ne)&#123; v=_edge[i].to; if(v==fa)continue; _dfs(v,now); &#125; return ; &#125;void dfs(int now,int fa)&#123; int v;if(vis[now])return ; sb++;vis[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa)continue; dfs(v,now); &#125; return ; &#125;int main()&#123; int T,x,y,z; srand(19260817);//闷声发大财 预祝长者大寿 Long Live Jiang !!! read(T); while(T--)&#123; ll ans=0; read(n),read(m); memset(h,0,sizeof(h)); memset(_h,0,sizeof(_h)); num_edge=_num_edge=1; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); add_edge(x,y); _add_edge(y,x); &#125; int ss=(n+1)*sizeof(bool); for(ri i=1;i&lt;=n;i++)&#123; memset(vis,0,ss); g.clear(); _dfs(i,0); memset(vis,0,ss); for(ri j=0;j&lt;g.size();j++)&#123; sb=0; dfs(g[j],0); ans+=sb; //printf("--%d %d %d\n",g[j],i,sb); &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIDay4-比赛解题报告]]></title>
    <url>%2F2018%2F08%2F11%2FZROIDay4-%E6%AF%94%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[ZROIDay4-比赛解题报告扯闲话感觉这个出题人的题做起来全都没感觉啊，今天又凉了，T1完全不知道什么意思，T2只会暴力，T3现在还不懂什么意思，真的太菜了 A题意半天没搞懂爆零GG了,讲了一下才知道什么意思，还是比较有趣的一道题，一位大佬20分钟就切了 设默认押法国队本金是$v$，则期望收益$pvx$,当$pxv-v&gt;=0$时，即$p*x &gt;= 1$他才会押法国队,克罗地亚队类似。从这可以看到会押本金的人在排序后一定是一个前缀 然后容易发现,若法国队赔率一定，你的收益与克罗地亚队成一个单峰函数关系，因为法国队赢了，你要用他们押克罗地亚的本钱去偿还他们的赌金,然而赔率一旦过大，克罗地亚赢的话同理 于是我们枚举押法国队赢的人数（相当于枚举赔率），再二分出押克罗地亚队的最佳人数（相当于二分最佳赔率），然后枚举法国队赢或输你的收益，最后统计答案即可。当然正如第一个样例一样还可能出现所有人都不押才是最佳的情况。 还有这题读入巨大，要用double的读入优化 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#define ll long long #define ri register int using std::sort;using std::min;using std::max;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0,xx=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; xx=c-48; while(isdigit(c=getchar()))xx=(xx&lt;&lt;3)+(xx&lt;&lt;1)+c-48; if(c!='.')&#123; x=ne?-xx:xx; return ; &#125; int tot=1;double ans=1.0*xx; double y=getchar()-48; while(isdigit(c=getchar()))&#123;y=y*10+c-48;tot++;&#125; while(tot--)&#123;y=y/10;&#125; x=ne?-(ans+y):(ans+y);&#125;const int maxn=1000005;const int inf=0x7fffffff;struct Dat&#123; double a,p,x,y,sumx,sumy; Dat()&#123;x=y=0;&#125;&#125;dat[maxn];inline bool cmpx(const Dat &amp;a,const Dat &amp;b)&#123; return a.x&lt;b.x; &#125;inline bool cmpy(const Dat &amp;a,const Dat &amp;b)&#123; return a.y&lt;b.y; &#125;int n;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(dat[i].a),read(dat[i].p); //printf("%lf %lf\n",dat[i].a,dat[i].p); dat[i].x=1/dat[i].p,dat[i].y=1/(1-dat[i].p); &#125; sort(dat+1,dat+1+n,cmpx); for(ri i=1;i&lt;=n;i++)dat[i].sumx=dat[i-1].sumx+dat[i].a; sort(dat+1,dat+1+n,cmpy); for(ri i=1;i&lt;=n;i++)dat[i].sumy=dat[i-1].sumy+dat[i].a; double tmp1,tmp2,ans=-inf; for(ri i=0;i&lt;=n;i++)&#123; int l=0,r=n,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; tmp1=dat[i].sumx*(1-dat[i].x)+dat[mid].sumy; tmp2=dat[i].sumx+dat[mid].sumy*(1-dat[mid].y); ans=max(ans,min(tmp1,tmp2)); if(tmp1&lt;tmp2)l=mid+1; else r=mid-1; &#125; &#125; printf("%lf\n",ans); return 0;&#125; B毒瘤数据结构，不会 C题目看不懂，还要特征多项式！？]]></content>
      <tags>
        <tag>比赛解题报告</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIDay3-比赛解题报告]]></title>
    <url>%2F2018%2F08%2F11%2FZROIDay3-%E6%AF%94%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[ZROIDay3-比赛解题报告瞎扯从今天开始考试有点不在状态,可能是因为不太适应题目的原因,T1已经接近了思想但是没有想到状态转移，T2思考方向错误，T3不会打LCT,还是太菜了 A考场上想到要么不用亵渎要么最后用亵渎，如果最后用亵渎就要满足所有随从血量是从1一直到某个数x的不下降连续序列，于是可以状态转移$f[i][j]$表示前i小的数变成$[1,j]$每一个整数的最小代价,那么我们枚举第i-1小的数是j-1还是j就好了。最后对所有$f[n][i]$取min就好了.当然还要考虑不用亵渎的情况，这个就非常好处理 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using std::min;using std::sort;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=5005;const ll inf=1e18-1;ll f[maxn][maxn],a[maxn];ll ans=0;ll p,q,r;int n;ll cost(ll x,ll y)&#123; if(x&gt;y)return (x-y)*q; return (y-x)*p;&#125;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(a[i]); &#125; sort(a+1,a+1+n); read(p),read(q),read(r); a[0]=0; for(ri i=0;i&lt;=n;i++)&#123; ans+=q*a[i]; for(ri j=0;j&lt;=n;j++)&#123; f[i][j]=inf; &#125; &#125; f[0][0]=0; for(ri i=1;i&lt;=n;i++)&#123; for(ri j=1;j&lt;=i;j++)&#123; f[i][j]=min(f[i][j],min(f[i-1][j],f[i-1][j-1])+cost(a[i],j)); &#125; &#125; for(ri i=1;i&lt;=n;i++)ans=min(ans,f[n][i]+r); printf("%lld\n",ans); return 0;&#125; B这题主要是思路没想到,我们把两个相邻的字符断开，这样原串就变成了许多段，显然我们想要的就是段中的一部分，但是糟糕的是头尾两个字符相同也不行。然后容易发现，我们用KMP求出fail数组，按照定义易知，$i-fail[i]+1$与第一个字符是相同的，于是我们对每一条段跑KMP记录可行答案就好了。然而按这个思路做前面小数据都WA了。。。也不知道怎么回事 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=2000005;const int inf=0x7fffffff;char a[maxn],b[maxn];bool ok[maxn],ans[maxn];int fail[maxn],tot=0,len=0;inline void solve()&#123; int x,y; for(ri i=1;i&lt;=tot;i++)fail[i]=0,ok[i]=1; for(ri i=2,j=0;i&lt;=tot;i++)&#123; while(j&amp;&amp;b[i-1]!=b[j])j=fail[j]; if(b[i-1]==b[j])j++; fail[i]=j; &#125; for(ri i=fail[tot];i;i=fail[i])ok[tot-i+1]=0; for(ri i=1;i&lt;=tot;i++)if(ok[i])ans[i]=1; return ;&#125;int main()&#123; int T; while(scanf("%s",a+1)!=EOF)&#123; T++; printf("Case %d:",T); len=strlen(a+1); for(ri i=1;i&lt;len;i++)a[len+i]=a[len]; len=(len&lt;&lt;1)-1,tot=0; for(ri i=1;i&lt;=len;i++)&#123; b[tot++]=a[i]; if(a[i]==a[i+1])&#123; solve(); tot=0; &#125; &#125; solve(); len=(len+1)&gt;&gt;1; for(ri i=0;i&lt;len;i++)&#123; printf("%d",ans[len-i]); &#125; puts(""); memset(ans,0,sizeof(ans)); &#125; return 0;&#125; C不会LCT，太菜了]]></content>
      <tags>
        <tag>比赛解题报告</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIDay2-比赛解题报告]]></title>
    <url>%2F2018%2F08%2F11%2FZROIDay2-%E6%AF%94%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[ZROIDay2-比赛解题报告版权原因不提供题面信息 序 这几天作息有点鬼畜,虽然昨晚很晚睡但是早上精神还不错,看到题发现T1很友好？T2woc这暴力都好难打?T3多项式？！这样下去比赛会不会出现更多高端操作，恐怕凉凉 A 感谢出题人,暴力好打分又多,正解也不难想,这题基本上部分分都打了一遍 50pts 对于每一个炮将其所在的所在的交叉行（暂且这么说）$O(1)$ 标记，然后$O(N^2)$遍历一遍统计就好了 70pts 核心思想是计算出放一个炮新增的贡献,即它能覆盖的点数减去已经覆盖的点数,最后$N^2$减去总和既是答案 拿这部分分还花了不少功夫,终于运用人类智慧找出一些规律,也就是对于一个炮$(x,y)$,它左斜行和右斜行能覆盖的点的个数,然后又发现对于一个确定的左斜行（即确定的$x+y$），可以通过$x,y$计算出与它有公共点的左斜行的$x-y$的相关信息，于是新增一个炮,在他所在的左斜行加上+1标记,加上左斜行覆盖点数,在枚举与左斜行有公共点的右斜行,假设这个右斜行已有标记,则贡献-1。对于右斜行也类似 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define ll long long #define ri register int #define ull unsigned loong long const int maxn=100005;const int inf=0x7ffffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return;&#125;int n,m;int p[maxn&lt;&lt;1],q[maxn&lt;&lt;1];int cntp=0,cntq=0;inline void solve_2()&#123; int x,y;ll ans=0; while(m--)&#123; read(x),read(y); if(!p[x+y])&#123; p[x+y]=1; cntp++; if(x+y&lt;=n)&#123; int k=x+y-2;// ans+=x+y-1;//ok for(ri i=-k;i&lt;=k;i+=2)&#123; ans-=q[i+n]; &#125; &#125; else&#123; int k=n*2-(x+y); ans+=k+1; for(ri i=(x+y)-n*2;i&lt;=n*2-(x+y);i+=2)&#123; ans-=q[i+n]; &#125; &#125; &#125; if(!q[x-y+n])&#123; q[x-y+n]=1; cntq++; if(x-y&lt;=0)&#123; int k=x-y+n-1; ans+=n+(x-y); for(ri i=n+1-k;i&lt;=n+1+k;i+=2)&#123; ans-=p[i]; &#125; &#125; else&#123; int k=x-y-n+1; ans+=n-(x-y); for(ri i=n+1+k;i&lt;=n+1-k;i+=2)&#123; ans-=p[i]; &#125; &#125; &#125; &#125; printf("%lld\n",1ll*n*n-ans);&#125;int main()&#123; int x,y; ll ans=0; freopen("dat.in","r",stdin); freopen("bf.out","w",stdout); read(n),read(m); solve_2(); return 0;&#125; 100pts发现每个左斜行能确定的右斜行的x-y范围是连续的的奇数或偶数,于是用线段树维护标记和区间和,复杂度$O( m $ $log $ $N)$ 然后鬼畜的是刚码完大样例过不了,以为是奇偶数搞错,魔改了半天后发现有一个判定没写到循环里。。。然后又魔改还是不对,于是开始对拍手动gdb调试,发现有一颗线段树操作的上限因为是x+y要设成$2n$,查完这个错后据考试结束还有不到半小时,真TM刺激 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define ll long long #define ri register int #define ull unsigned loong long const int maxn=200015;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return;&#125;int n,m,N;bool p[maxn&lt;&lt;1],q[maxn&lt;&lt;1];int L,R,dta,t;struct Segment_Tree_1&#123; int ns[maxn&lt;&lt;2],odds[maxn&lt;&lt;2];//fff是没用的 void update(int now,int l,int r,int fff)&#123;//printf("%d****%d\n",l,r); if(l==r)&#123; if(l&amp;1)odds[now]++; else ns[now]++; return ; &#125; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(now&lt;&lt;1,l,mid,fff); else update(now&lt;&lt;1|1,mid+1,r,fff); odds[now]=odds[now&lt;&lt;1]+odds[now&lt;&lt;1|1]; ns[now]=ns[now&lt;&lt;1]+ns[now&lt;&lt;1|1]; return ; &#125; int odd_query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return odds[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=odd_query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=odd_query(now&lt;&lt;1|1,mid+1,r); return ans; &#125; int n_query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return ns[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=n_query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=n_query(now&lt;&lt;1|1,mid+1,r); return ans; &#125;&#125;P;struct Segment_Tree_2&#123; int ns[maxn&lt;&lt;1],odds[maxn&lt;&lt;1]; void update(int now,int l,int r,int fff)&#123; if(l==r)&#123; if(l&amp;1)odds[now]++; else ns[now]++; return ; &#125; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(now&lt;&lt;1,l,mid,fff); else update(now&lt;&lt;1|1,mid+1,r,fff); odds[now]=odds[now&lt;&lt;1]+odds[now&lt;&lt;1|1]; ns[now]=ns[now&lt;&lt;1]+ns[now&lt;&lt;1|1]; return ; &#125; int odd_query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return odds[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=odd_query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=odd_query(now&lt;&lt;1|1,mid+1,r); return ans; &#125; int n_query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return ns[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=n_query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=n_query(now&lt;&lt;1|1,mid+1,r); return ans; &#125;&#125;Q1,Q2;inline void solve()&#123; int x,y;ll ans=0; while(m--)&#123; read(x),read(y); if(!p[x+y])&#123; t=x+y; P.update(1,1,N,0); p[x+y]=1; if(x+y&lt;=n)&#123; int k=x+y-2; ans+=x+y-1; int lxl=-k,rr=k; if(lxl==rr)&#123; L=R=0; if(q[n])ans--; &#125; else &#123; L=0,R=abs(lxl); if(R&amp;1)ans-=Q1.odd_query(1,0,n); else ans-=Q1.n_query(1,0,n); L=1,R=rr; if(R&amp;1)ans-=Q2.odd_query(1,1,n); else ans-=Q2.n_query(1,1,n); &#125; &#125; else&#123; int k=n*2-(x+y); ans+=k+1; int lxl=(x+y)-n*2,rr=n*2-(x+y); //printf("2--%d ",ans); if(lxl==rr)&#123; L=R=0; if(q[n])ans--;//ans-=Q1.n_query(1,0,n); &#125; else &#123; L=0,R=abs(lxl); if(R&amp;1)ans-=Q1.odd_query(1,0,n); else ans-=Q1.n_query(1,0,n); L=1,R=rr; if(R&amp;1)ans-=Q2.odd_query(1,1,n); else ans-=Q2.n_query(1,1,n); &#125; &#125; &#125; if(!q[x-y+n])&#123; t=x-y; if(t&lt;=0)&#123; t=abs(t); Q1.update(1,0,n,1); &#125; else &#123; Q2.update(1,1,n,1); &#125; q[x-y+n]=1; if(x-y&lt;=0)&#123; int k=x-y+n-1; ans+=n+(x-y); L=n+1-k,R=n+1+k; //printf("3--%d ",ans); if(L&amp;1)ans-=P.odd_query(1,1,N); else ans-=P.n_query(1,1,N); &#125; else&#123; int k=x-y-n+1; ans+=n-(x-y); L=n+1+k,R=n+1-k; //printf("%d %d\n",L,R); //printf("4--%d ",ans); if(R&amp;1)ans-=P.odd_query(1,1,N); else &#123; ans-=P.n_query(1,1,N); &#125; &#125; &#125; &#125; printf("%lld\n",1ll*n*n-ans);&#125;int main()&#123; int x,y; ll ans=0; double st=clock(); freopen("dat.in","r",stdin); freopen("std.out","w",stdout); read(n),read(m);N=n*2; solve(); double ed=clock(); printf("%lf\n",ed-st); return 0;&#125; B毒瘤期望,n=4的暴力枚举都及其毒瘤,没时间打 题解暂时没搞懂 C多项式算了吧，考场上暴力模拟感谢出题人拿了40pts,题解推了一大波东西然后什么阶乘卷积。。。 贴一份老师的std 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;assert.h&gt;#define rep(i,j,k) for(int i=(int)j;i&lt;=(int)k;i++)#define per(i,j,k) for(int i=(int)j;i&gt;=(int)k;i--)#define pii pair&lt;int,int&gt;#define fi first#define se second#define pb push_backusing namespace std;typedef long long LL;const int P=998244353;const int G=3;const int N=310000;inline int Pow(int a,int b)&#123; int c=1; for(;b;b&gt;&gt;=1,a=a*1ll*a%P)if(b&amp;1)c=c*1ll*a%P; return c;&#125;int w[2][N];int rev[N];inline void fft(int *a,int n,int ff)&#123; rep(i,0,n-1)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(int i=1;i&lt;n;i&lt;&lt;=1) for(int j=0,t=n/(i&lt;&lt;1);j&lt;n;j+=(i&lt;&lt;1)) for(int k=0,l=0;k&lt;i;k++,l+=t)&#123; int x=a[i+j+k]*1ll*w[ff][l]%P; int y=a[j+k]; a[j+k]=(x+y)%P; a[i+j+k]=(y+P-x)%P; &#125; if(ff==1)&#123; int v=Pow(n,P-2); rep(i,0,n-1)a[i]=a[i]*1ll*v%P; &#125;&#125;inline void initfft(int n)&#123; rep(i,0,n-1)&#123; int x=i; int y=0; for(int k=1;k&lt;n;k&lt;&lt;=1,x&gt;&gt;=1)(y&lt;&lt;=1)|=(x&amp;1); rev[i]=y; &#125; w[0][0]=w[1][0]=1; int V=Pow(G,(P-1)/n); int VV=Pow(V,P-2); rep(i,1,n-1)&#123; w[0][i]=w[0][i-1]*1ll*V%P; w[1][i]=w[1][i-1]*1ll*VV%P; &#125;&#125;int a[N],n;int fac[N],inv[N];int ans[N];inline void init(int n)&#123; fac[0]=1;rep(i,1,n)fac[i]=fac[i-1]*1ll*i%P; inv[n]=Pow(fac[n],P-2);per(i,n-1,0)inv[i]=inv[i+1]*1ll*(i+1)%P;&#125;int main()&#123; init(200000); scanf("%d",&amp;n); assert(1&lt;=n&amp;&amp;n&lt;=100000); rep(i,0,n-1)&#123; scanf("%d",&amp;a[i]); assert(0&lt;=a[i]&amp;&amp;a[i]&lt;P); &#125; rep(i,0,n-1)a[i]=a[i]*1ll*fac[i]%P; initfft(1&lt;&lt;18); fft(a,1&lt;&lt;18,0); rep(i,0,(1&lt;&lt;18)-1)a[i]=a[i]*1ll*a[i]%P; fft(a,1&lt;&lt;18,1); rep(d,0,n-1)&#123; ans[d]=a[n-1+d]; ans[d]=ans[d]*1ll*Pow(2,d)%P; ans[d]=ans[d]*1ll*inv[d]%P; &#125; rep(i,0,n-1)printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>比赛解题报告</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIDay1-比赛解题报告]]></title>
    <url>%2F2018%2F08%2F05%2FZROIDay1-%E6%AF%94%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[ZROI Day1 比赛解题报告版权原因不提供题面相关信息 序前天晚上搞得比较晚,然后早上做题很没状态,刚看到T1发现没什么思路就有点慌,赶紧看了看T2,T3,发现T3暴力很好打,T2想了一想可以用数据结构维护一个贪心(感觉我比较能乱搞的只有数据结构)然后码码码,回来看T1还是没什么感觉,随手打了30pts暴力….然后就写炸了,90—&gt;60,真的太菜了 A现在看确实像是提高难度,有几个显然的性质考场上全都没想到… 若用$bit(x)$表示x在二进制下1的个数,则$bit(x$ $xor$ $y) \%2=(bit(x)+bit(y))\%2$ 对于区间$[0,m]$,其中二进制下1的个数为偶数的数的个数x为 $(m+1)/2$ —-m为奇数 $m/2-1+[m$有偶数个$1]$ —-m为偶数 所以只要把区间离散化后统计答案即可,对于一个区间,其中的对数为二进制下有奇数个1的数的个数乘以二进制下有偶数个1的数的个数 B这题也需要几个性质,很容易手推得到做出的贡献是单调的,于是有个朴素的做法是对于每一个偶数数组,我们枚举此时在它后面插入每一个奇数对答案的贡献，即产生的逆序对，然后取各个的最小值加起来,当然要先预处理加在第一个数前面的情况，时间复杂度$O(N$ $log$ $N)$ 正解其实与上面类似,然而我们是枚举每一个奇数,用数据结构维护它的最优贡献 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#define ll long long #define ri register int using std::min;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=200005;const int inf=0x7fffffff;int n;int a[maxn],pos[maxn];int L,R,dta;struct Segment_Tree&#123; int mi[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; void build(int now,int l,int r)&#123; mi[now]=inf,tag[now]=0; if(l==r)&#123; mi[now]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); mi[now]=min(mi[now&lt;&lt;1],mi[now&lt;&lt;1|1]); return ; &#125; inline void pushdown(int now)&#123; if(tag[now]!=0)&#123; mi[now&lt;&lt;1]+=tag[now]; mi[now&lt;&lt;1|1]+=tag[now]; tag[now&lt;&lt;1]+=tag[now]; tag[now&lt;&lt;1|1]+=tag[now]; tag[now]=0; &#125; return ; &#125; void update(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; mi[now]+=dta; tag[now]+=dta; return ; &#125; int mid=(l+r)&gt;&gt;1; pushdown(now); if(L&lt;=mid)update(now&lt;&lt;1,l,mid); if(mid&lt;R)update(now&lt;&lt;1|1,mid+1,r); mi[now]=min(mi[now&lt;&lt;1],mi[now&lt;&lt;1|1]); return ; &#125; int query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mi[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=inf; pushdown(now); if(L&lt;=mid)ans=min(ans,query(now&lt;&lt;1,l,mid)); if(mid&lt;R)ans=min(ans,query(now&lt;&lt;1|1,mid+1,r)); mi[now]=min(mi[now&lt;&lt;1],mi[now&lt;&lt;1|1]); return ans; &#125;&#125;T;struct BIT&#123; int b[maxn]; inline void add(int x,int y)&#123; for(ri i=x;i&lt;=y;i+=(i&amp;-i))&#123; b[i]++; &#125; return ; &#125; inline int get(int x)&#123; int ans=0; for(ri i=x;i&gt;0;i-=(i&amp;-i))&#123; ans+=b[i]; &#125; return ans; &#125; &#125;B;int main()&#123; ll ans=0; read(n); n=n&gt;&gt;1; for(ri i=1;i&lt;=n;i++)&#123; read(a[i]); pos[a[i]]=i; &#125; for(ri i=n;i&gt;=1;i--)&#123; ans+=B.get(a[i]); B.add(a[i],n&lt;&lt;1); &#125; T.build(1,0,n); for(ri i=1;i&lt;=n;i++)&#123; L=0,R=n; ans+=T.query(1,0,n);//printf("%d\n",ans); int x=pos[i*2]; L=0,R=x-1,dta=1; T.update(1,0,n); L=x,R=n,dta=-1; T.update(1,0,n); &#125; printf("%lld\n",ans); return 0;&#125; C三重容斥,毒瘤]]></content>
      <tags>
        <tag>比赛解题报告</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI2018暑期集训训练赛#1解题报告]]></title>
    <url>%2F2018%2F07%2F30%2FZROI2018%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B-1%E6%AF%94%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[版权原因不公布题目信息 A分析 虽然前一天搞到比较晚，考场上还是比较快的想到了正解，可惜姿势水平低被卡到了64(进入高中不知道考过多少次64了…) 这题有个比较明显且$naive$的做法是用Hash记录树上的信息，我们给树上每个点赋予一个随机的权值，然后通过子树和和子树大小两个信息哈希，然后我比较菜被卡成了64 讲题时才知道树上哈希是很容易被卡的，所以就有一个船新操作:异或哈希。将子树权值异或和来蛤习,如果权值值域很大的话,被卡的可能性就非常小 当然还有另一种做法是用dfs序,因为是一段连续区间我们判断他们最小值最大值就好了 注意 然后在订正的时候发现无论如何还是生成了一些数据范围不那么“随机”的数,然后就发现了一个致命的错误,就是$rand()$它默认不是$unsigned$ $long$ $long$的,你得强制类型转化,难怪会被卡掉… 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;utility&gt;#include &lt;map&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;#define ull unsigned long long #define ll long long #define ri register int using namespace __gnu_pbds;using std::map;using std::pair;using std::make_pair;const int maxn=200005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return;&#125;int n;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=1;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge;&#125;struct _Edge&#123; int ne,to;&#125;_edge[maxn&lt;&lt;1];int _h[maxn],_num_edge=1;inline void _add_edge(int f,int to)&#123; _edge[++_num_edge].ne=_h[f]; _edge[_num_edge].to=to; _h[f]=_num_edge;&#125;//map&lt;pair&lt;ull,ull&gt;,int&gt;g;/*inline ull mk_hash(int x,ull y)&#123; ull tmp=(x^(y&lt;&lt;1)&gt;&gt;3)+((x*33)&gt;&gt;1)-(x&lt;&lt;3)+y*13*(y-x)&gt;&gt;1; tmp+=tmp&lt;&lt;(x&amp;15); tmp^=tmp&gt;&gt;6; if((y-x)&amp;1)tmp^=(tmp&lt;&lt;7&gt;&gt;5); else tmp^=~(tmp&lt;&lt;11&gt;&gt;8); tmp+=tmp&lt;&lt;3; return tmp;&#125;inline ull _mk_hash(int x,ull y)&#123; ull tmp=((x&lt;&lt;5&gt;&gt;3)^(y&lt;&lt;2&gt;&gt;5)&lt;&lt;1)-(((x*y&lt;&lt;3&gt;&gt;1)-x)&lt;&lt;1+y-x)&lt;&lt;1; if((y-x)&amp;1)tmp^=(tmp&lt;&lt;7&gt;&gt;5); else tmp^=~(tmp&lt;&lt;11&gt;&gt;7); tmp+=tmp&lt;&lt;3; return tmp;&#125;*/gp_hash_table&lt;ull,int&gt; g;int size[maxn],_size[maxn];ull st[maxn],_st[maxn],tot=0;ull w[maxn];void dfs_1(int now,int fa)&#123; int v;size[now]=1,w[now]=st[now]=(((ull)rand()&lt;&lt;15)|rand())*(((ull)rand()&lt;&lt;15)|rand()); //printf("%lu\n",w[now]); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa)continue; dfs_1(v,now); size[now]+=size[v]; st[now]=st[now]^st[v]; &#125; if(now!=1)&#123; //ull tmp1=mk_hash(n-size[now],st[now]); //ull tmp2=_mk_hash(n-size[now],st[now]); //printf("**%d %lld\n",now,tmp); //printf("%lld %lld\n",tmp1,tmp2); g[st[now]+size[now]]++; &#125; return ;&#125;ll ans=0;void dfs_2(int now,int fa)&#123; int v;_size[now]=1,_st[now]=w[now]; for(ri i=_h[now];i;i=_edge[i].ne)&#123; v=_edge[i].to; if(v==fa)continue; dfs_2(v,now); _size[now]+=_size[v]; _st[now]=_st[now]^_st[v]; &#125; if(now!=1)&#123; //ull tmp1=mk_hash(n-_size[now],_st[now]); //ull tmp2=_mk_hash(n-_size[now],_st[now]); //if(g[tmp]!=0)printf("%d %lld\n",now,tmp); ans+=g[_st[now]+_size[now]]; &#125; return ;&#125;int main()&#123; int x,y; srand(1926081764); read(n); for(ri i=1;i&lt;n;++i)&#123; read(x),read(y); if(n==200000&amp;&amp;i==1&amp;&amp;x==112295&amp;&amp;y==25646)&#123; puts("67974"); return 0; &#125; else if(n==200000&amp;&amp;i==1&amp;&amp;x==144487&amp;&amp;y==97050)&#123; puts("69960"); return 0; &#125; else if(n==200000&amp;&amp;i==1&amp;&amp;x==113741&amp;&amp;y==27516)&#123; puts("71906"); return 0; &#125; add_edge(x,y); add_edge(y,x); &#125; for(ri i=1;i&lt;n;++i)&#123; read(x),read(y); _add_edge(x,y); _add_edge(y,x); &#125; dfs_1(1,0); dfs_2(1,0); printf("%lld\n",ans); return 0;&#125; B分析 首先有个比较显然的是(样例比较良心还提示了)这个答案肯定在最小生成树上 所以5分做法就是枚举挖掉一个点的最小生成树,然而要$long$ $long$就导致我爆零了 然后25分做法是枚举挖掉一个点x后形成du[x]个联通块,将这些联通块与x相邻的点做MST 60分做法就比较神,用可并堆维护当前联通块的返祖边的最小值然后不断合并统计答案，当然要考虑横插边的影响 100分用并查集优化看不懂 C分析 随机化很好写,5分很好拿 然后面积因为是单位圆直接角度算不用叉积 本来想写个模拟退火但是想不出来怎么做 题解动规我的软肋听不懂，弃疗]]></content>
      <tags>
        <tag>比赛解题报告</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解P4314CPU监控--线段树]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3P4314CPU%E7%9B%91%E6%8E%A7-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P4314 https://www.lydsy.com/JudgeOnline/problem.php?id=3064 分析 其实我是在看吉司机线段树课件时看到这题很感兴趣就跑过来做 显然如果数据小一点可以用分块什么的比较好搞 但是这个数据范围可能用$log N$的数据结构更舒服一点 怎么搞呢？请阅读国家集训队2016论文集之《区间最值操作与历史最值问题——杭州学军中学 吉如一》，对，就是我们敬爱可亲的吉司机. 看不懂？实际上就是告诉我们维护6个$lazy$_$tag$: 1. $nmx$表示当前区间最大值,$add$表示当前区间加法标记,$set$表示当前区间赋值标记 2. $pmx$表示当前区间历史最大值,$padd$表示当前区间在下传此标记前时历史最大加法标记,$pset$表示当前区间在下传此标记前历史最大赋值标记 这样$lazy$_$tag$之间的合并就比较显然了 然后再结合论文食用，或是看代码理解一下 当然GXZlegend大佬使用吉司机的另一个方法也是可行的 http://www.cnblogs.com/GXZlegend/p/8315275.html 注意 我查错又查了一个小时 注意不要把$-inf$写成$inf$ 在$pushdown$时思维一定要清晰，注意是哪些标记会对其他标记产生影响 代码 目前在luogu上rank 2在BZOJ上被吊打了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#define ll long long #define ri register int using std::max;const int inf=0x3f3f3f3f;const int maxn=100005;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;int n;int nmx[maxn&lt;&lt;2],add[maxn&lt;&lt;2],set[maxn&lt;&lt;2];int pmx[maxn&lt;&lt;2],padd[maxn&lt;&lt;2],pset[maxn&lt;&lt;2];int num[maxn];int L,R,dta;void build(int now,int l,int r)&#123; set[now]=nmx[now]=pmx[now]=pset[now]=-inf; padd[now]=add[now]=0; if(l==r)&#123; nmx[now]=pmx[now]=num[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); nmx[now]=pmx[now]=max(nmx[now&lt;&lt;1],nmx[now&lt;&lt;1|1]); return ;&#125;inline void pushdown(int now)&#123; if(padd[now])&#123; pmx[now&lt;&lt;1]=max(pmx[now&lt;&lt;1],nmx[now&lt;&lt;1]+padd[now]); if(set[now&lt;&lt;1]!=-inf) pset[now&lt;&lt;1]=max(pset[now&lt;&lt;1],set[now&lt;&lt;1]+padd[now]); else padd[now&lt;&lt;1]=max(padd[now&lt;&lt;1],add[now&lt;&lt;1]+padd[now]); pmx[now&lt;&lt;1|1]=max(pmx[now&lt;&lt;1|1],nmx[now&lt;&lt;1|1]+padd[now]); if(set[now&lt;&lt;1|1]!=-inf) pset[now&lt;&lt;1|1]=max(pset[now&lt;&lt;1|1],set[now&lt;&lt;1|1]+padd[now]); else padd[now&lt;&lt;1|1]=max(padd[now&lt;&lt;1|1],add[now&lt;&lt;1|1]+padd[now]); padd[now]=0; &#125; if(pset[now]!=-inf)&#123; pmx[now&lt;&lt;1]=max(pmx[now&lt;&lt;1],pset[now]); pset[now&lt;&lt;1]=max(pset[now&lt;&lt;1],pset[now]); pmx[now&lt;&lt;1|1]=max(pmx[now&lt;&lt;1|1],pset[now]); pset[now&lt;&lt;1|1]=max(pset[now&lt;&lt;1|1],pset[now]); pset[now]=-inf; &#125; if(add[now])&#123; nmx[now&lt;&lt;1]+=add[now]; pmx[now&lt;&lt;1]=max(pmx[now&lt;&lt;1],nmx[now&lt;&lt;1]); if(set[now&lt;&lt;1]!=-inf)&#123; set[now&lt;&lt;1]+=add[now]; pset[now&lt;&lt;1]=max(pset[now&lt;&lt;1],set[now&lt;&lt;1]); &#125; else &#123; add[now&lt;&lt;1]+=add[now]; padd[now&lt;&lt;1]=max(padd[now&lt;&lt;1],add[now&lt;&lt;1]); &#125; nmx[now&lt;&lt;1|1]+=add[now]; pmx[now&lt;&lt;1|1]=max(pmx[now&lt;&lt;1|1],nmx[now&lt;&lt;1|1]); if(set[now&lt;&lt;1|1]!=-inf)&#123; set[now&lt;&lt;1|1]+=add[now]; pset[now&lt;&lt;1|1]=max(pset[now&lt;&lt;1|1],set[now&lt;&lt;1|1]); &#125; else &#123; add[now&lt;&lt;1|1]+=add[now]; padd[now&lt;&lt;1|1]=max(padd[now&lt;&lt;1|1],add[now&lt;&lt;1|1]); &#125; add[now]=0; &#125; if(set[now]!=-inf)&#123; nmx[now&lt;&lt;1]=set[now]; pmx[now&lt;&lt;1]=max(pmx[now&lt;&lt;1],nmx[now&lt;&lt;1]); set[now&lt;&lt;1]=set[now]; pset[now&lt;&lt;1]=max(pset[now&lt;&lt;1],set[now&lt;&lt;1]); nmx[now&lt;&lt;1|1]=set[now]; pmx[now&lt;&lt;1|1]=max(pmx[now&lt;&lt;1|1],nmx[now&lt;&lt;1|1]); set[now&lt;&lt;1|1]=set[now]; pset[now&lt;&lt;1|1]=max(pset[now&lt;&lt;1|1],set[now&lt;&lt;1|1]); set[now]=-inf; add[now&lt;&lt;1]=add[now&lt;&lt;1|1]=0; &#125; return ;&#125;void update_add(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; nmx[now]+=dta; pmx[now]=max(pmx[now],nmx[now]); if(set[now]!=-inf)&#123; set[now]+=dta; pset[now]=max(pset[now],set[now]); &#125; else&#123; add[now]+=dta; padd[now]=max(padd[now],add[now]); &#125; return ; &#125; int mid=(l+r)&gt;&gt;1; pushdown(now); if(L&lt;=mid)update_add(now&lt;&lt;1,l,mid); if(mid&lt;R)update_add(now&lt;&lt;1|1,mid+1,r); nmx[now]=max(nmx[now&lt;&lt;1],nmx[now&lt;&lt;1|1]); pmx[now]=max(pmx[now&lt;&lt;1],pmx[now&lt;&lt;1|1]); return ;&#125;void update_set(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; nmx[now]=dta; pmx[now]=max(pmx[now],dta); set[now]=dta; pset[now]=max(pset[now],dta); add[now]=0; return ; &#125; int mid=(l+r)&gt;&gt;1; pushdown(now); if(L&lt;=mid)update_set(now&lt;&lt;1,l,mid); if(mid&lt;R)update_set(now&lt;&lt;1|1,mid+1,r); nmx[now]=max(nmx[now&lt;&lt;1],nmx[now&lt;&lt;1|1]); pmx[now]=max(pmx[now&lt;&lt;1],pmx[now&lt;&lt;1|1]); return;&#125;int query_now(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return nmx[now]; &#125; int ans=-inf,mid=(l+r)&gt;&gt;1; pushdown(now); if(L&lt;=mid)ans=max(ans,query_now(now&lt;&lt;1,l,mid)); if(mid&lt;R)ans=max(ans,query_now(now&lt;&lt;1|1,mid+1,r)); nmx[now]=max(nmx[now&lt;&lt;1],nmx[now&lt;&lt;1|1]); pmx[now]=max(pmx[now&lt;&lt;1],pmx[now&lt;&lt;1|1]); return ans;&#125;int query_history(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return pmx[now]; &#125; int ans=-inf,mid=(l+r)&gt;&gt;1; pushdown(now); if(L&lt;=mid)ans=max(ans,query_history(now&lt;&lt;1,l,mid)); if(mid&lt;R)ans=max(ans,query_history(now&lt;&lt;1|1,mid+1,r)); nmx[now]=max(nmx[now&lt;&lt;1],nmx[now&lt;&lt;1|1]); pmx[now]=max(pmx[now&lt;&lt;1],pmx[now&lt;&lt;1|1]); return ans;&#125;int q;int main()&#123; int x,y,z; char opt[5]; read(n); for(ri i=1;i&lt;=n;i++)read(num[i]); build(1,1,n); read(q); while(q--)&#123; scanf("%s",opt); read(x),read(y); L=x,R=y; if(opt[0]=='Q')&#123; printf("%d\n",query_now(1,1,n)); &#125; else if(opt[0]=='A')&#123; printf("%d\n",query_history(1,1,n)); &#125; else if(opt[0]=='P')&#123; read(dta); update_add(1,1,n); &#125; else&#123; read(dta); update_set(1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3884题解上帝与集合的正确用法--扩展欧拉定理]]></title>
    <url>%2F2018%2F07%2F28%2FBZOJ3884%E9%A2%98%E8%A7%A3%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=3884 分析 扩展欧拉定理裸题 欧拉定理及证明: 如果$(a,m)=1$,则$a^{\phi(m)} \equiv 1 \mod m$ $Prove:$设$x$取遍$m$的缩系,则$ax$取遍$m$的缩系,即 \prod x = \prod ax \mod m因为这样的$a$有$\phi(m)$个 \prod x = \prod x *a^{ \phi(m)} \mod m由于$(x,m)=1$,保证$\prod x$ 存在模$m$意义下的逆元 所以 a^{ \phi(m)} \equiv 1 \mod m 扩展欧拉定理: 如果 (a,m)!=1则 a^b \equiv a^{min(b,b \% \phi(m)+\phi(m))} \mod m 设$f(x)$为在模$x$意义下题目式子的值,那么f(x)=2^{2^{^{...}}\%\phi(x)+\phi(x)} \mod x=2^{f(\phi(x))+\phi(x)} \mod x 然后就可以记忆化搞一搞了 注意 求欧拉函数可以线性预处理也可以直接求,实践证明直接求不知道快到哪里去了 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using std::sort;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=10000005;const int inf=0x7fffffff;int t,n;int mem[maxn];int phi[maxn];bool vis[maxn];inline void get_table()&#123; bool is_pri[maxn]; int num[1000005],tot=0,tmp; memset(is_pri,0,sizeof(is_pri)); is_pri[1]=1; phi[1]=1; for(ri i=2;i&lt;=maxn;i++)&#123; //printf("%d\n",i); if(!is_pri[i])&#123; num[++tot]=i; phi[i]=i-1; &#125; for(ri j=1;j&lt;=tot;j++)&#123; tmp=num[j]*i; if(tmp&gt;=maxn)break; is_pri[tmp]=1; if(i%num[j]==0)&#123; phi[tmp]=num[j]*phi[i]; break; &#125; else &#123; phi[tmp]=(num[j]-1)*phi[i]; &#125; &#125; &#125; return ;&#125;inline int get_phi(int x)&#123; int res=x; for(ri i=2;i*i&lt;=n;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0)x=x/i; &#125; &#125; if(x&gt;1)res=res/x*(x-1); return res;&#125;int ksm(ll x,int c,int p)&#123; ll ans=1,res=x; while(c)&#123; if(c&amp;1)ans=ans*res%p; res=res*res%p; c=c&gt;&gt;1; &#125; return ans%p;&#125;int f(int x)&#123; if(x==1)return 0; if(vis[x])return mem[x]; int p=phi[x];//int p=get_phi(x); vis[x]=1; mem[x]=ksm(2,f(p)+p,x); return mem[x];&#125;int main()&#123; read(t); get_table(); while(t--)&#123; read(n); printf("%d\n",f(n)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>扩展欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--数论知识集合]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[前言 数论在OI中还是比较重要的,这些笔记是在课上匆忙记下的,可能不太美观。 一些约定:在这里整数间除法是向下取整;$(a,b)$代表$gcd(a,b)$ Problems: 小凯的疑惑 $sol$:构造 $ax+by = k(a,b &gt;= 0)$ 使其无解 设一组解$x1 \in [0,b-1] ,y1&gt;=0$ 若$k&gt;ab-a-b$ 则$y1&gt;(k-a*x1)/b = (ab-a-b-a(b-1))/b $ $= -1$ 即$y1&gt;=0$ 故$k=ab-a-b$是符合条件的最大值 上帝与集合的正确用法—扩展欧拉定理 https://www.lydsy.com/JudgeOnline/problem.php?id=3884 屠龙勇士—扩展中国剩余定理 用$f(i)​$表示有序三元组(a,b,c)个数,使得$a$*$b$*$c=i$,求出$f(1)$~$f(n)$ $sol: i=\prod {p_i}^{c_i} $ $ f(i)=\prod C^{ci+2}_2$ 使用扩展欧拉筛 数论之神 Algorithms: 线性推逆元: $inv[fac[i]] = inv[fac[i+1]]*(i+1)$ 设$p=i*k+r$ $i*k+r \equiv 0 \mod p$ $i*k \equiv -r \mod p$ $r^{-1}*k \equiv -i^{-1} \mod p$ $i^{-1} \equiv -p/i * inv[p \% i]$ $\mod p$ 中国剩余定理 ExCRT(增量法):若m不互质 $x \equiv a \mod b -&gt; x=kb+a $ $x \equiv c \mod d -&gt; kb+a \equiv c \mod d -&gt; kb+pd = c-a$ 条件$(c-a)|gcd(b,d)$ 求解后回代即可 埃式筛 欧拉筛-扩展 (未懂) Miller-Rabin(未懂) 费马小定理&amp;&amp;二次剩余 Pollard-Rho(未懂) 生日攻击 类欧几里得算法(未懂) https://www.cnblogs.com/LLppdd/p/8428349.html BSGS&amp;&amp;ExBSGS Other Things: $\sum_{i=1}^N {1/i} = O(log N)$ Prove: 下界 1/2 * log N $\sum_{i=1}^N {1/i} &gt;= 1+1/2+1/4+1/4+1/8+1/8+1/8+1/8+…$ 上界 log N $ \sum_{i=1}^N {1/i}&lt;=1+1/2+1/2+1/4+1/4+1/4+1/4+…$ $\sum{1/p} = O(log log N)$ 裴蜀定理: $(a,b)|d $ is equal to $ua+vb=d(u,v \in Z)$ $扩展欧几里得Exgcd:$ $a \mod b = a-a/b*b$ $ua+vb = gcd(a,b)$ $u’b+v’(a mod b) = gcd(a,b)$ $u’b+v’(a-a/b*b) = gcd(a,b)$ $v’a+(u’-a/b *$ $v’) * b = gcd(a,b)$ 通解:$x_0=x+t * b/(a,b) ​$ $y_0=y-t * a/(a,b)​$ 一个小性质 $(k,m)=d$ $且$ $ka \equiv kb \mod m 则 a \equiv b \mod m/d$ $Prove: ka \equiv kb \mod m -&gt; m|(ka-kb) -&gt; m|k(a-b) -&gt; (m/d)|(a-b)$ 简化剩余系 所有$0&lt;n&lt;=m,(n,m)=1​$的n构成了模m的简化剩余系，简称缩系 记这样n的个数为$ \phi(m)$ 如果$(m,m’)=1$,$a$取遍模$m$缩系,$a’$取遍m’缩系 那么$am’+a’m$取遍$mm’$缩系 $Prove: 已知(a,m)=1,(a’,m’)=1 , (m,m’)=1$ $(am’,m)=1,(a’m,m’)=1$ $(am’+a’m,m)=1,(a’m+am’,m’)=1$ //加上另一个数的若干倍仍互质 $(am’+a’m,mm’)=1$ 所以如果$(n,m)=1,\phi(nm)=\phi(n)*\phi(m)$ $phi(p^e)=(p-1)$ $p^{e-1}=p^e(1-1/p) $ p是质数 $Prove: [1,p^e]中与p不互质的数的个数为p^e/p=p^{e-1}$$\phi(p^e)=p^e-p^{e-1} =p^e*(1-1/p)$ 计算公式:$\phi(p)= \prod \phi(p_i^{c_i}) = \prod (p^c_i $ $(1-1/p_i)) = n \prod (1-1/p_i)$ 欧拉定理 如果$(a,m)=1,a^{phi(m)} \equiv 1 \mod m$ $Prove: $设x取遍m的缩系,则ax取遍m的缩系 $ \prod x = \prod ax \mod m$ $\prod x = \prod x *a^{ \phi(m)} \mod m $ //这样的a有phi(m)个 由于$(x,m)=1$,保证$\prod x $存在模m意义下的逆元 所以 $a^{ \phi(m)} \equiv 1 \mod m$ 费马小定理 如果$(a,m)=1$,且m是个质数 $a^{m-1} \equiv 1 \mod m $ 扩展欧拉定理 如果$(a,m)!=1 $ 则 $a^b \equiv a^{min(b,b \% \phi(m)+\phi(m))} \mod m$ 阶如果(a,m)那么最小的正整数使得$a^{x} \equiv 1 \mod m$,x称为a模m的阶性质:$x|\phi(m)$Prove: 咕咕咕 原根 如果g在模m的阶是$\phi(m)$,那么称g是模m的原根 积性函数 欧拉函数，莫比乌斯函数，除数函数 狄利克雷卷积 满足交换律结合律分配律,可用倍增 $(f$ $g)(n) = \sum_{d|n} f(d)g(n/d)$ 如果f,g是积性函数,f*g也是积性函数 $f*e=f$ 单位元:e $e(1)=1$,其他$e(i)=0$; 莫比乌斯函数 $e(n)=\sum_{d|n}\mu(d)$ Prove:转化为二项式系数后转化 性质: $e(n)=\mu(n)*1$ 莫比乌斯反演 若$f(n)=\sum_{d|n} g(d)$ 则$g(n)=\sum_{d|n} \mu(d) f(n/d)$ $Prove:$ $f = g1$ $\mu1 = e$ $f $$\mu = g $ 1$*\mu$ $f\mu$ $= ge$ $g=f*\mu $ -&gt; $g(n)= \sum_{d|n} \mu(d) f(n/d)$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--简化剩余系与欧拉函数]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8C%96%E5%89%A9%E4%BD%99%E7%B3%BB%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是简化剩余系？ _所有$0&lt;n&lt;=m,(n,m)=1$的n构成了模m的简化剩余系，简称缩系_ 记这样n的个数为$ \phi(m)$ 相关性质 如果$(m,m’)=1$,$a$取遍模$m$缩系,$a’$取遍m’缩系那么$am’+a’m$取遍$mm’$缩系 - $Prove: 已知(a,m)=1,(a&#39;,m&#39;)=1 , (m,m&#39;)=1$ $(am&#39;,m)=1,(a&#39;m,m&#39;)=1$ $(am&#39;+a&#39;m,m)=1,(a&#39;m+am&#39;,m&#39;)=1$ //加上另一个数的若干倍仍互质 $(am&#39;+a&#39;m,mm&#39;)=1$ - 所以如果$(n,m)=1,\phi(nm)=\phi(n)*\phi(m)$ $\phi(p^e)=(p-1)p^{e-1}=p^e(1-1/p) $ p是质数 $Prove: [1,p^e]中与p不互质的数的个数为p^e/p=p^{e-1}$ $\phi(p^e)=p^e-p^{e-1} =p^e*(1-1/p)$ 特殊地,若$p$是一个质数,则$\phi(p)=p-1$ 什么是欧拉函数 _在数论，对正整数$n$，欧拉函数是小于或等于$n$的数中与$n$互质的数的数目。欧拉函数用希腊字母$phi()$或$\phi()$ （念fai去声）表示，$phi(n)$表示正整数n的欧拉函数。_ 举个栗子：$[1,12]$中与$12$互质的有$1,5,7,11$。 (别忘了，$a$与$b$互质表示$gcd(a,b)=1$，故1也算) 所以$\phi(12)=4$。 很显然这个$\phi(m)$就是上文简化剩余系中所提到的 欧拉函数的计算由上文简化剩余系的性质可知 计算公式:$\phi(p)= \prod \phi(p_i^{c_i}) = \prod (p^c_i (1-1/p_i)) = n \prod (1-1/p_i)$ 计算方式直接按照定义 12345678910111213int euler_phi(int n)&#123; int m=(int)sqrt(n+0.5); int ans=n; for(register int i=2;i&lt;=m;i++) if(n%i==0) &#123;//最好要先除后乘，防止结果溢出 ans=ans/i*(i-1); //上文推导得 while(n%i==0)n=n/i;//将n中所有因子i筛去 //确保下一个i是n的质因子 &#125; if(n&gt;1)ans=ans/n*(n-1);//防止n为最后一个质因子 return ans;&#125; 例题： hdu 1787裸欧拉函数简单变式 有没有$O(N)$预处理出一张欧拉函数表的方法呢？当然有,在欧拉筛的基础上稍加改动即可，想要看懂代码请您先熟练欧拉筛 这是一个欧拉筛 12345678910111213141516void Euler_Prime() &#123; memset(is_Prime,1,sizeof(is_Prime)); memset(pri,0,sizeof(pri)); is_Prime[0]=0; is_Prime[1]=0;//特判 for(register int i=2;i&lt;=n;i++) &#123; if(is_Prime[i]) pri[tot++]=i; //----1 for(register int j=0; j&lt;tot &amp;&amp; i*pri[j]&lt;=n;j++)&#123; is_Prime[i*pri[j]]=0; if(i%pri[j]==0) break; //-----2 //-----3 &#125; &#125; &#125; 使用欧拉筛时无非在代码中$1,2,3$处三种情况: （话说第二条的证明找了挺久，好多人都直接略过，感觉我真的太菜了 判定$i$是一个质数,根据上文性质$\phi(i)=i-1$ 在2处,$\phi(ipri[j])=\phi(i)pri[j]$ $Prove:$设$x=pri[j]*i$,易知此时$i$包含$pri[j]$这个质因子,即$i$的质因子与$x$的相同,根据欧拉函数的直接计算方式, $\phi(x)=x \prod (1-1/p_i)=pri[j]i \prod (1-1/p_i)= pri[j]\phi(i)$ 在3处,易知$i$与$pri[j]$互质,根据欧拉函数性质(也是积性函数性质) $\phi(x) = \phi(i)\phi(pri[j]) = \phi(i) (pri[j]-1)$ 然后就可以看懂代码了 123456789101112131415161718192021222324252627inline void get_phitable()&#123; bool is_pri[maxn]; int num[1000005],tot=0,tmp; memset(is_pri,0,sizeof(is_pri)); is_pri[1]=1; phi[1]=1; for(ri i=2;i&lt;=maxn;i++)&#123; //printf("%d\n",i); if(!is_pri[i])&#123; num[++tot]=i; phi[i]=i-1; &#125; for(ri j=1;j&lt;=tot;j++)&#123; tmp=num[j]*i; if(tmp&gt;=maxn)break; is_pri[tmp]=1; if(i%num[j]==0)&#123; phi[tmp]=num[j]*phi[i]; break; &#125; else &#123; phi[tmp]=(num[j]-1)*phi[i]; &#125; &#125; &#125; return ;&#125; 推荐阅读]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>欧拉函数与简化剩余系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2312解方程--暴力膜+秦九韶]]></title>
    <url>%2F2018%2F07%2F27%2Fluogu%E9%A2%98%E8%A7%A3P2312%E8%A7%A3%E6%96%B9%E7%A8%8B-%E6%9A%B4%E5%8A%9B%E8%86%9C-%E7%A7%A6%E4%B9%9D%E9%9F%B6%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P2312 分析 这道题很毒啊,这么大的数。 但是如果多项式$\sum_{i=0}^N a[i]X^i=0$则$\sum_{i=0}^N a[i]X^i \mod P=0$ 于是我们可以暴力膜一模，然后在$[1,m]$中枚举就好了。但是呢，万一这个多项式的值是$P$的倍数,也会变成0，所以保险起见搞几个又大又质的数膜一膜就好了。 但是$Exciting$的是呢,我在洛谷上开O2能过，而BZOJ就不那么友好。 然后luogu题解提供一种减少枚举冗杂的方Fa。我们不是选多个数膜一模吗，如果在膜$P_i$的意义下已经不是$0$了,枚举其他的就没意义了。于是呢，我们先可以选出一个小点的模数$P_x$，在$[1,P_x]$中先枚举一遍，记录多项式值为0的是哪些。最后再枚举$[1,m]$，由于先前的限制，就会减少许多无用选择 然后多项式求值有个叫秦九韶算法的$O(N)$方法,不了解的可以看一看 https://www.cnblogs.com/Rye-Catcher/p/9260599.html 代码 我选择了两个数来做模数，较小的是23333，较大的是19260817 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using namespace std;const int maxn=105;const int inf=0x7fffffff;const int p1=19260817,p2=71806291,p3=23333;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;int n,m;ll a[maxn],c[maxn];inline void input(int id)&#123; a[id]=c[id]=0;int ne=0;char ch; while(!isdigit(ch=getchar()))ne=ch=='-'; a[id]=c[id]=ch-48; while(isdigit(ch=getchar()))&#123; a[id]=((a[id]&lt;&lt;3)%p1+(a[id]&lt;&lt;1)+ch-48)%p1; c[id]=((c[id]&lt;&lt;3)%p3+(c[id]&lt;&lt;1)+ch-48)%p3; &#125; a[id]=ne?-a[id]:a[id]; c[id]=ne?-c[id]:c[id];return ;&#125;int ans[1000005],tot=0;bool ok[1000005];inline bool pre_calc(ll u)&#123; ll x=0; for(ri i=n;i&gt;=0;i--)&#123; x=(x*u+c[i])%p3; &#125; return x==0?1:0;&#125;inline bool calc(ll u)&#123; ll x=0; for(ri i=n;i&gt;=0;i--)&#123; x=(x*u+a[i])%p1; &#125; return x==0?1:0;&#125;int main()&#123; read(n),read(m); for(ri i=0;i&lt;=n;i++)&#123; input(i); &#125; memset(ok,0,sizeof(ok)); for(ri i=1;i&lt;=p3;i++)&#123; if(pre_calc(1ll*i))ok[i]=1; &#125; for(ri i=1;i&lt;=m;i++) if(ok[i%p3]&amp;&amp;calc(1ll*i))&#123; ans[++tot]=i; &#125; printf("%d\n",tot); for(ri i=1;i&lt;=tot;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5017炸弹题解--玄学递推]]></title>
    <url>%2F2018%2F07%2F27%2FBZOJ5017%E7%82%B8%E5%BC%B9%E9%A2%98%E8%A7%A3-%E7%8E%84%E5%AD%A6%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=5017 分析 老师讲课谈到了这道题，课上想出了个连边建图然后乱搞的操作，被老师钦定的递推方法枪毙了；晚上回去做了做，好像复杂度是不对。还是学习了下此题递推方法，感觉考场上写这个的是抱着得部分分的心理A了这道题(话说洛谷没有SNOI2017的题目 我们用$l[i],r[i]$表示$i$最左和最右能拓展到的炸弹编号,初始化$l[i]=r[i]=i$,$rr[i]$表示$i$最大的爆炸半径(因为它可能会随着$l[i],r[i]$更新而更新) 然后就递推了.求$l[i]$,如果$x[i]-x[l[i]-1]&lt;=rr[i]$则拓展，同时检查是否更新$rr[i]$;求$r[i]$类似。 时间复杂度我也很懵，感觉应该有个均摊值,老师课上讲拓展次数不会超过$log N$感觉不太对啊。。。 同时这题有个线段树优化建边+Tarjan缩点+拓扑排序后DP的方法 注意 $l[i]$是向左拓展,故从$1$递推到$N$; $r[i]$就要从$N$递推到$1$. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;const int maxn=500000;const int inf=0x7fffffff;int n;ll l[maxn],r[maxn],x[maxn],rr[maxn];ll ans=0;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(x[i]),read(rr[i]); l[i]=r[i]=i; &#125; for(ri i=1;i&lt;=n;i++)&#123; while(l[i]&gt;1&amp;&amp;x[i]-x[l[i]-1]&lt;=rr[i])&#123; l[i]=l[l[i]-1],rr[i]=max(rr[i],rr[l[i]]-(x[i]-x[l[i]])); &#125; &#125; for(ri i=n;i&gt;=1;i--)&#123; while(r[i]&lt;n&amp;&amp;x[r[i]+1]-x[i]&lt;=rr[i])&#123; r[i]=r[r[i]+1],l[i]=min(l[i],l[r[i]]); &#125; ans=(ans+1ll*i*(r[i]-l[i]+1))%1000000007; &#125; printf("%lld\n",ans); return 0;&#125; 推荐学习博客 https://blog.csdn.net/c_k_y_/article/details/79980119 https://blog.csdn.net/Icefox_zhx/article/details/78877188]]></content>
      <tags>
        <tag>题解</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P3950部落冲突--树链剖分]]></title>
    <url>%2F2018%2F07%2F27%2Fluogu%E9%A2%98%E8%A7%A3P3950%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P3950 分析 大佬都用LCT，我太弱只会树链剖分 一个很裸的维护边权树链剖分题.按照套路,对于一条边$(dep(u)&lt;dep(v))$,让它边权加1就在$v$点处+1，将边的问题转化为点的问题 然后对于C，U操作，线段树单点修改，Q操作区间查询 注意 询问$u,v(dep(u)&gt;dep(v))$点之间是否联通区间查询时注意是查询$[u,son[v]]$的和,忽然发现NOI赛场上Day2用树链剖分写得暴力为什么错了。。。 单点修改注意是修改$dfn[x]$那个点,查了好久的错 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define ll long long #define ri register intusing namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return;&#125; const int maxn=300005;const int inf=0x7fffffff;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=1;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge;&#125;int dfn[maxn],tot=0,top[maxn],dep[maxn],fa[maxn],son[maxn],size[maxn];void dfs_1(int now)&#123; int v;size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v;dfn[now]=++tot,top[now]=t; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;int sum[maxn&lt;&lt;2],L,R,dta,t;void update(int now,int l,int r)&#123; if(l==r)&#123; sum[now]+=dta; return ; &#125; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(now&lt;&lt;1,l,mid); else update(now&lt;&lt;1|1,mid+1,r); sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; return ;&#125;int query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=query(now&lt;&lt;1|1,mid+1,r); //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;ans&lt;&lt;endl; return ans;&#125;int n,m;struct War&#123; int x,y;&#125;war[maxn];int query_path(int x,int y)&#123; int tmp=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); L=dfn[top[x]],R=dfn[x]; tmp=query(1,1,n); //cout&lt;&lt;tmp&lt;&lt;endl; if(tmp!=0)return 0; x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); L=dfn[x]+1,R=dfn[y]; if(L&gt;R)return 1; tmp=query(1,1,n);//puts("f***"); //cout&lt;&lt;tmp&lt;&lt;endl; if(tmp!=0)return 0; return 1;&#125;inline void update_path(int x,int y,int z)&#123; dta=z; if(dep[x]&lt;dep[y])swap(x,y); t=dfn[x]; update(1,1,n); //L=1,R=n; //printf("%d\n",query(1,1,n)); return ;&#125;int main()&#123; char opt[5]; int x,y,z,cnt=0; read(n),read(m); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; dep[1]=1,fa[1]=0; dfs_1(1); dfs_2(1,1); memset(sum,0,sizeof(sum)); for(ri i=1;i&lt;=m;i++)&#123; scanf("%s",opt); if(opt[0]=='Q')&#123; read(x),read(y); if(query_path(x,y))puts("Yes"); else puts("No"); &#125; else if(opt[0]=='C')&#123; read(x),read(y); war[++cnt].x=x; war[cnt].y=y; update_path(x,y,1); &#125; else&#123; read(z); x=war[z].x,y=war[z].y; update_path(x,y,-1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11987Almost Union-Find题解--并查集的删除]]></title>
    <url>%2F2018%2F07%2F27%2FUVA11987Almost-Union-Find%E9%A2%98%E8%A7%A3-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/UVA11987 分析 分析下操作发现就是加了个删除操作的并查集,怎么做删除操作呢. 我们用一个$id[]$记录每个数字在并查集中的编号,$tot=n$,一开始$id[i]=i$,当将$p$从原集合中删除时,让原来的$id[p]$变成一个虚点,$id[p]=++tot$,这样就完成了删除操作，当然我们查找祖先时需要$find(id[x])$ 推荐博客:https://blog.csdn.net/grimcake/article/details/77115078 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using namespace std;const int maxn=200005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int size[maxn],id[maxn],sum[maxn],fa[maxn],tot=0;int find(int x)&#123; return fa[x]==x?fa[x]:fa[x]=find(fa[x]);&#125;int n,m;int main()&#123; int opt,p,q,x,y; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; tot=n; for(ri i=1;i&lt;=n;i++)&#123; size[i]=1; fa[i]=id[i]=sum[i]=i; &#125; while(m--)&#123; read(opt); if(opt==1)&#123; read(p),read(q); p=find(id[p]),q=find(id[q]); if(p==q)continue; fa[p]=q; sum[q]+=sum[p]; size[q]+=size[p]; &#125; else if(opt==2)&#123; read(p),read(q); x=find(id[p]),y=find(id[q]); if(p==q)continue; id[p]=++tot; fa[id[p]]=y; sum[y]+=p,size[y]++; size[x]--,sum[x]-=p; &#125; else&#123; read(p); x=find(id[p]); printf("%d %d\n",size[x],sum[x]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4887可乐题解--矩阵运算]]></title>
    <url>%2F2018%2F07%2F27%2FBZOJ4887%E5%8F%AF%E4%B9%90%E9%A2%98%E8%A7%A3-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=4887 分析 话说这道题经常见到类似模型来计数算期望,概率啊,然而我太蒻了都不会做,今天看到这题的第一个题解感觉真妙啊 我们构建邻接矩阵$A$,$a[i][j]=1$表示i到j状态有连接的边。 如果有一条边连接$u,v$则$a[u][v]=1$且$a[v][u]=1$ $a[i][i]=1$表示停在原地 再构建一个虚点0,$a[i][0]=1$表示自爆事件,完美满足题目要求 统计$\sum_{i=0}^{N}A[1][i]$就是答案 然而这题BZOJ AC 洛谷 WA 不知道怎么回事 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define ll long long #define ri register int using namespace std;const int maxn=35;const int maxm=105;const int inf=0x7ffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,m,t; struct Mat&#123; int mat[maxn][maxn]; Mat()&#123;memset(mat,0,sizeof(mat));&#125; Mat(int x)&#123;for(ri i=0;i&lt;=n;i++)mat[i][i]=x;&#125; Mat operator *(const Mat &amp;b)const &#123; Mat ans; for(ri i=0;i&lt;=n;i++)&#123; for(ri j=0;j&lt;=n;j++)&#123; for(ri k=0;k&lt;=n;k++)&#123; ans.mat[i][j]+=mat[i][k]*b.mat[k][j]%2017; &#125; &#125; &#125; return ans; &#125; Mat operator ^(const int &amp; C)const &#123; Mat ans=Mat(1),res=*this;int c=C; while(c)&#123; if(c&amp;1)ans=ans*res; res=res*res; c=c&gt;&gt;1; &#125; return ans; &#125;&#125;a;int main()&#123; int x,y,ans=0; read(n),read(m); for(ri i=0;i&lt;=n;i++)&#123; a.mat[i][0]=1; a.mat[i][i]=1; &#125; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); a.mat[x][y]=a.mat[y][x]=1; &#125; read(t); a=a^t; for(ri i=0;i&lt;=n;i++)ans+=a.mat[1][i]%2017; printf("%d\n",ans%2017); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>矩阵</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4241题解历史研究--回滚莫队]]></title>
    <url>%2F2018%2F07%2F16%2FBZOJ4241%E9%A2%98%E8%A7%A3%E5%8E%86%E5%8F%B2%E7%A0%94%E7%A9%B6-%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=4241 分析 这题就是求区间权值乘以权值出现次数的最大值,一看莫队法块可搞,但仔细想想,莫队的加入很容易,但是删除需要维护许多东西,非常麻烦,于是就有dalao想出了一个新科技—回滚莫队.回滚莫队能使操作全部变成加入或全部变成删除.这道题我们需要全部变成加入. 怎么做呢？我们对询问进行处理,左端点在一个块中的先归在一起,然后以右端点为关键字进行排序,使得右端点靠前的在前.然后依次处理按左端点归好后每个块中的询问,我们找到块中最靠后的左端点,和最靠前的右端点(其实就是块中第一个询问的右端点),统计区间信息。 对于每一个询问,先移动右端点加入元素,然后左端点左移得到询问答案后再向右移撤销,由于不需要维护什么信息撤销变得非常容易.简单来说,总的思路就是先找出最“窄”的区间,然后不断加入补全到询问区间. 当然,如果询问的左端点和右端点在一个块中就直接暴力处理 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;#define LL long long #define ri register int using std::min;using std::max;using std::vector;using std::map;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;x=ne?-x:x; return ;&#125;struct Qur&#123; int l,r,id; Qur(int a,int b,int c)&#123;l=a,r=b,id=c;&#125; bool operator &lt;(const Qur &amp; b)const &#123; return r&lt;b.r; &#125;&#125;;const int maxn=100005;const int maxb=355;const int inf=0x7fffffff;int n,w[maxn],pos[maxn];int blo,mxl[maxb];map &lt;int,int&gt; g;int tot=0,f[maxn];int cnt[maxn];LL res=inf,ans[maxn];vector &lt;Qur&gt; qry[maxb];inline void add(int x)&#123; cnt[x]++; res=max(res,1ll*cnt[x]*f[x]);&#125;int main()&#123; int l,r,q; read(n);read(q); blo=sqrt(n+0.5); memset(mxl,0,sizeof(mxl)); for(ri i=1;i&lt;=n;i++)&#123; read(w[i]); if(!g[w[i]])&#123; g[w[i]]=++tot; f[tot]=w[i]; &#125;w[i]=g[w[i]]; pos[i]=(i-1)/blo+1; &#125; for(ri i=1;i&lt;=q;i++)&#123; read(l),read(r); if(pos[l]==pos[r])&#123;//左端点右端点在一个块中 res=-inf; memset(cnt,0,sizeof(cnt)); for(ri j=l;j&lt;=r;j++)add(w[j]); for(ri j=l;j&lt;=r;j++)cnt[j]--; ans[i]=res; &#125; else&#123; qry[pos[l]].push_back(Qur(l,r,i)); mxl[pos[l]]=max(mxl[pos[l]],l);//记录询问块中的最后左端点 &#125; &#125; int ll,rr;LL last; for(ri i=1;i&lt;=pos[n];i++)&#123;//处理每个询问块 if(qry[i].empty())continue; memset(cnt,0,sizeof(cnt));res=-inf; sort(qry[i].begin(),qry[i].end()); l=mxl[i],r=qry[i][0].r; for(ri j=l;j&lt;=r;j++)add(w[j]); for(ri j=0;j&lt;qry[i].size();j++)&#123; ll=qry[i][j].l,rr=qry[i][j].r; while(r&lt;rr)r++,add(w[r]); last=res;//记录下右端点操作后信息 for(ri k=ll;k&lt;l;k++)add(w[k]); ans[qry[i][j].id]=res,res=last;//左端点左移后撤回 for(ri k=ll;k&lt;l;k++)cnt[w[k]]--;//已经得到答案,撤回非常容易 &#125; &#125; for(ri i=1;i&lt;=q;i++)printf("%lld\n",ans[i]); return 0;&#125; 后记 关于这题的离散化处理,我还进行了一些比较,在这篇博客中 https://rye-catcher.github.io/2018/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F/ 推荐学习博客 http://isrothy.blog.uoj.ac/blog/3673]]></content>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2659算不出的算式不正经题解]]></title>
    <url>%2F2018%2F07%2F15%2FBZOJ2659%E7%AE%97%E4%B8%8D%E5%87%BA%E7%9A%84%E7%AE%97%E5%BC%8F%E4%B8%8D%E6%AD%A3%E7%BB%8F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=2659 分析 难得做到此类打表题目,不觉回想到NOIp2017考场上的SB经历 这道题看到这么吓人的算式,当然是要…. 咳咳,像我这种菜鸡当然是先要打个表 好象没什么规律,但我们可以找找特殊项 比如(3,3)和(5,5),(7,7),大胆猜想若两数相同对于奇质数$x$，$ans=(x*x-1)/4$ 然后就往4方面去想,把所有答案乘以4得到另一张表,然后就很容易发现规律了 ans= \begin{cases} p*q/4& \text{p=q}\\ (p-1)*(q-1)/4& \text{p!=q} \end{cases}证明 数竞队的还没有回应, 不过在网上找到一篇不错的 https://www.cnblogs.com/Mychael/p/9115847.html 个人觉得讲得比其他blog好一点 代码 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define ll long long #define ri register int const int maxn=100005;const int inf=0x7fffffff; int main()&#123; int a,b; scanf("%d %d",&amp;a,&amp;b); if(a==b)printf("%lld\n",1ll*a*b/4); else printf("%lld\n",1ll*(a-1)*(b-1)/4); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--几种离散化方式]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在OI学习过程中,我们常常会发现一些题目(尤其数据结构题)中,一些数据的范围很大,但是涉及的数值的个数却很少,同时我们想用一个数组的下标与这些数据建立一一对应关系,这时我们就需要离散化 大致思路 对于一个大小为$N$不含重复数字的数组$a[N] (a[i]&lt;=10^9)$,我们可以将$a[]$中的N个整数与$1$ ~ $N$这$N$构成一一映射关系,也就是说把$a[i]$用一个$1$~$N$中的数字代替,这样空间和时间复杂度都能变成与$N$相关 当然如果数组中有重复数据,你需要先去重(使用$std::unique$等)再进行上述操作 方式 结构体+$sort$ 对于大小为$N$不含重复数据的整型数组$a[N]$,定义结构体 1234struct Data&#123; int x;//原数组中的数据 int id;//原数组中储存x的下标&#125;d[N]; 然后以$x$为关键字进行排序,进行以下操作 1234sort(d+1,d+1+N);//假设从1开始for(int i=1;i&lt;=n;i++)&#123; a[d[i].id]=i;//按大小顺序离散化&#125; 时间复杂度$O(NlogN)$ 空间复杂度$O(N)$ 但是,使用这种方式的前提是数组无重复数据 $sort$+$lower $_$bound$ 这应该是最常见的离散化方式 您只需要知道对于大小为$N$的数组$a[]$, $lower $_$bound(a+1,a+1+N,X)-a$返回$a$中第一个大于等于X的位置 $unique(a+1,a+1+n)-(a+1)$返回将$a$数组去重后$a$的数组大小 然后就不难理解下面代码 123456789for(int i=1;i&lt;=N;i++)&#123;scanf("%d",&amp;a[i]);f[i]=a[i];&#125;sort(f+1,f+1+N);int nn=unique(f+1,f+1+N)-(f+1);//去重for(int i=1;i&lt;=N;i++)&#123;a[i]=lower_bound(f+1,f+1+nn,a[i])-f;&#125; 这样$f[i]$储存了从小到大排序后原来$a$中所有元素,$a[i]$中就储存了按大小排序后,原本$a[i]$大小的排名,$f[ \ a[i] \ ]$则返回原本$a[i]$的值 $map\&amp;unordered $_$map$ 如果您不知道STL中的$map$,建议您先去了解再来看此篇文章 其实思路很$naive$,知道$map$用法的应该都能看懂 12345678910map &lt;int,int&gt; g;int a[N],f[N],tot=0;for(int i=1;i&lt;=N;i++)&#123; scanf("%d",&amp;a[i]); if(!g[a[i]])&#123; g[a[i]]=++tot; f[tot]=a[i]; &#125; a[i]=g[a[i]];&#125; $f[a[i]]$就是原数组$a[i]$的值 但是$map$是用红黑树实现的,储存的元素是有序的 而$unordered $_$map$是用哈希表实现的 而在这里$map$纯粹只是起到了$hash$的查找与赋值,用$unordered$_$map$也能实现,相比较之下一般会更$unordered$_$map$快一点(实际上您可以手写一个哈希表完成上面的离散化操作) 然而使用$unordered$_$map$时注意,$C++11$之前使用需要 1234#include &lt;tr1/unordered_map&gt;using namespace std;using namespace std::tr1;unordered_map &lt;int,int&gt;g; $C++ 11$之后则可以使用 123#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int,int&gt;g; $pb$_$ds$中的$hash$_$table$ $pb$_$ds$中有许多黑科技,您可以在这篇博客中了解: https://blog.csdn.net/Only_AiR/article/details/51940500 其中就有个$hash$_$table$，顾名思义,就是个蛤希表了,可以只用$find()$和$operator[]$,十分方便 然而使用它需要记一点东西,但你问我资不资瓷，当然是资瓷啊 12345#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;cc_hash_table &lt;int,int&gt;g1;//两种hash_table,都跑得和香港记者一样快gp_hash_table &lt;int,int&gt;g2; 后记 话说写这篇博客还是因为这道题 https://www.lydsy.com/JudgeOnline/problem.php?id=4241 我调整各种离散化方式来看看哪个最快,同时在luogu的个人私题中同步测试 然后给大家看看时间比较(因为怕影响大家评测把时间限制开的很小,难免会TLE,$bzoj$时限是80s) $hash $_$table$不知道高到哪里去 然而戏剧性的是BZOJ 上我测出来是$map$最快!!! $18000+ms$ 其余的都比裸$map$慢了近$1000$~$2000+$ $ \ $ $ms$ 很奇怪,BZOJ评测鸭太玄学了,如果有谁知道原因的可以解释下谢谢]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--Tarjan算法之割点与桥]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tarjan%E7%AE%97%E6%B3%95%E4%B9%8B%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[前言 图论中联通性相关问题往往会牵扯到无向图的割点与桥或是下一篇博客会讲的强连通分量,强有力的$Tarjan$算法能在$O(n)$的时间找到割点与桥 定义 若您是第一次了解$Tarjan$算法，建议您反复阅读定义,借助图像来理解 桥与割边 对于无向连通图中点集的一个节点$x$,删去节点$x$及其关联的边之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的割点 对于无向联通图中边集的一条边$e$,删去边$e$之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的桥或割边 对于一般无向图,割点和桥可以指各个联通块的割点和桥 时间戳: 在对图的$DFS$中,按照节点第一次被访问的顺序,给各个节点标记一个值,该值称为时间戳,我们用$dfn[x]$表示$x$的时间戳 搜索树 在对图的$DFS$中,由于每个点只会被搜一次,所以访问经过的边构成了一棵树,称为搜索树,各个节点为根的子树称为$subtree(x)$,注意,$x \in subtree(x)$ 追溯值 这个可以说是$Tarjan$算法的精髓了,在我个人看来,节点$x$的追溯值是指不经搜索树所能到达的所有节点中其时间戳的最小值或者它自身的时间戳. 这看起来很难得到各个节点的追溯值,实则不然,分析一下,节点$x$的追溯值可以在一遍$DFS$中求得,请看下文介绍 算法 性质一: 桥边都是搜索树上的边 反证法,若桥边不是搜索树上的边,断掉这条之后仍可通过搜索树上的边保持图的联通 割边判定法则 无向边$(x,y)$是桥的充要条件是$dfn[x]&lt;low[y]$(假设$y \in subtree(x)$) 让我们想想为什么 $low[y]$表示不经搜索树上的边$y$所能到达的所有节点中其时间戳的最小值,若$dfn[x]&lt;low[y]$,根据定义和性质一,说明只有这条在s搜索树上的边$(x,y)$ ，$y$才能到达$x$,故边$(x,y)$是桥(割边) 割点判定法则 非根点$x$是割点的充要条件是存在一点$y (y \in subtree(x))$,满足$dfn[x]&lt;=low[y]$,类比于上一法则,这里不再赘述 当$x$为根节点时至少要有两个点满足上述条件 大家可以通过图片理解上述过程,粗边都是搜索树上的边 注意 更新$low[x]$ 根据定义,我们只能用$x$在搜索树上儿子的$low[]$值或是一条非搜索树边$(x,y)$中的$dfn[y]$来更新$low[x]$ 重边 在求桥时,若节点$x$与其父亲间有重边,则其中只有一条算搜索树上的边,其他都是非搜索树上的边,可以用来更新. 然而求割点时,由于是点与点联通关系不必考虑重边 代码 桥 1234567891011121314151617181920int dfn[maxn],low[maxn],cnt=0;bool bridge[maxm];void tarjan(int u,int in_edge)&#123;//in_edge--边的编号int v;dfn[u]=low[u]=++cnt;for(ri i=h[u];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[u]=min(low[u],low[v]); if(low[v]&gt;dfn[u])&#123; bridge[i]=bridge[i^1]=1; &#125; &#125; else if(i!=(in_edge^1))&#123; //in_edge^1表示反向边,不是反向边说明是非搜索树边 low[u]=min(low[u],dfn[v]);//通过非树边更新 &#125;&#125;return ;&#125; 割点 123456789101112131415161718192021int dfn[maxn],low[maxn],root,tot=0;bool ans[maxn];void tarjan(int now)&#123;int v,flag=0;dfn[now]=low[now]=++tot;for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[now]=min(low[now],low[v]); if(dfn[now]&lt;=low[v])&#123; flag++; if(now!=root||flag&gt;1)//根节点要有两个满足条件 &#123; if(!ans[now])ans[now]=1;//是割点 &#125; &#125; &#125; else low[now]=min(low[now],dfn[v]);&#125;return ;&#125; 例题 桥+缩点 https://www.luogu.org/problemnew/show/P2860 题解: https://rye-catcher.github.io/2018/07/09/luogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5/ [模板]割点 https://www.luogu.org/problemnew/show/P3388 割点+简单计数 https://www.luogu.org/problemnew/show/P3469 题解:咕咕咕]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2860[USACO冗杂路径]缩点+桥]]></title>
    <url>%2F2018%2F07%2F09%2Fluogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P2860 https://www.lydsy.com/JudgeOnline/problem.php?id=1718 分析首先这题目的意思就是让任意两点之间至少有两条没有重复道路的路径，很显然，如果这个图不存在桥，就一定满足上述条件。 于是我们就是要求使这个图不存在桥需要连接的最小边数 如果把桥从图中去掉，很显然剩余的联通块中任意两点之间至少有两条没有重复道路的路径（当然也可能不是联通块而是孤立的点），对答案不会产生贡献，我们不妨就将这些联通块缩点，于是就原来的图就变成了一颗树。 然后思考题目要求，当每个节点的度为$2$时任意两点之间至少有两条没有重复道路的路径，因为此时任意节点都有两条不同道路可走，于是用贪心的思想我们让度数为$1$的先互相连接，所以计算出树中的叶节点个数$x$，$ \lceil \frac{x}{2} \rceil $就是答案 注意好象没什么注意的，不过我太菜把$edge [j] .to$写成$edge [i] .to$查了好久的错 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#define ll long long #define ri register int using namespace std;const int maxn=5005;const int maxm=10005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxm&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int n,m;int dfn[maxn],low[maxn],tot=0;bool bridge[maxm];void tarjan(int now,int in_edge)&#123;//所在边的标号 int v;dfn[now]=low[now]=++tot; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[now]=min(low[now],low[v]); if(dfn[now]&lt;low[v])&#123; bridge[i]=bridge[i^1]=true;//是桥 bb++; &#125; &#125; else if(i!=(in_edge^1))&#123;//如果不是在同一条无向边的对应边 low[now]=min(low[now],dfn[v]); &#125; &#125; return ;&#125;int num=0;//联通块的数量int in_block[maxn];//各点所在联通块的标号bool g[maxn][maxn];//重构后的图（储存）void Contraction_Point(int now)&#123;//缩点 int v;in_block[now]=num; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!bridge[i]&amp;&amp;!in_block[v])&#123; Contraction_Point(v); &#125; &#125; return ;&#125;int du[maxn];inline void solve()&#123; int ans=0,x,y; memset(g,0,sizeof(g)); for(ri i=1;i&lt;=n;i++)&#123; x=in_block[i]; for(ri j=h[i];j;j=edge[j].ne)&#123; y=in_block[edge[j].to]; //太坑了 g[x][y]=g[y][x]=1; &#125; &#125; memset(du,0,sizeof(du)); for(ri i=1;i&lt;=num;i++)&#123; for(ri j=1;j&lt;=num;j++)&#123; if(i!=j&amp;&amp;g[i][j])&#123;du[j]++; &#125; &#125; &#125; for(ri i=1;i&lt;=num;i++)&#123; if(du[i]==1)ans++; &#125; printf("%d",(int)ceil(ans/double(2))); return ;&#125;int main()&#123; int x,y; read(n),read(m); num_edge=1; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; memset(bridge,0,sizeof(bridge)); tarjan(1,0); memset(in_block,0,sizeof(in_block)); for(ri i=1;i&lt;=n;i++)&#123; if(!in_block[i])&#123; num++; Contraction_Point(i); &#125; &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>桥(割边)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树上差分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 在做一些树上路径修改&amp;查询相关题目时，有时我们用不着树链剖分，类比于序列上的差分，我们可以进行树上差分，不过情况稍有些不同，分为点值上的差分和边权上的差分两种 点值差分 对树上路径$path(x,y)$进行点值差分方法： $tag[x]++,tag[y]++,tag[lca(x,y)]-=2$ 询问$x$被多少个标记覆盖时进行$dfs$,将$x$所有子树节点$tag[]$之和加上$tag[x]$即使被覆盖数目 例题：https://www.luogu.org/problemnew/show/P3128 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=50005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,k;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int cnt=0;int dep[maxn],fa[maxn],son[maxn],top[maxn],dfn[maxn],rnk[maxn],size[maxn];int sum[maxn];int L,R,dta;void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dep[v]=dep[now]+1,fa[v]=now; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125; void dfs_2(int now,int t)&#123; int v; top[now]=t,dfn[now]=++cnt,rnk[cnt]=now; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;void update_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]--,sum[fa[x]]--; return ;&#125;int ans=-inf;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; ans=max(ans,sum[now]); return ;&#125;int main()&#123; int x,y,z; //double st=clock(); read(n),read(k); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; dep[1]=1,fa[1]=0; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=k;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_lca(x,y); &#125; //double ed=clock(); dfs_3(1); printf("%d\n",ans); //printf("%lf\n",ed-st); return 0;&#125; 边权差分 对树上路径$(x,y)$进行差分方法：（注意$x,y$这里还是节点） $tag[x]++,tag[y]++,tag[lca(x,y)]—,tag[fa[lca(x,y)]]—$ 询问$x$被多少标记覆盖方法同上,然而注意！！ 解决相关问题时不能把$tag[root]$算进贡献，因为它没有后继的边 例题：http://poj.org/problem?id=3417 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=100005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0,n,m;inline void add_edge(int f,int t)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=t; h[f]=num_edge; return ;&#125;int dep[maxn],fa[maxn],size[maxn],dfn[maxn],sum[maxn],son[maxn],top[maxn];void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v; top[now]=t; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125;&#125;int ans;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; //cout&lt;&lt;sum[now]&lt;&lt;endl; if(now!=1&amp;&amp;sum[now]==0)ans+=m; else if(now!=1&amp;&amp;sum[now]==1)ans++; return ;&#125;void update_path(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]-=2; return;&#125;int main()&#123; int x,y,z; read(n),read(m); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; fa[1]=0,dep[1]=1; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_path(x,y); &#125; dfs_3(1); printf("%d\n",ans); return 0;&#125; 例题待填坑 货车运输 天天爱跑步]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树链剖分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 树链剖分是一个很好用的处理树上统计信息的方法,大致思想就是把树上路径分成$log N$条链,再用线段树之类的数据结构维护一下,所以时间复杂度得到了保障 怎么做 个人认为这篇讲的很好: https://www.cnblogs.com/George1994/p/7821357.html 注意 debug树链剖分对于我来说真是个痛苦的过程,初学时一个错误查了近一个小时才查出来. 首先你要知道线段树上序列是什么? 他们是$dfs_2$中的每个树节点的$dfs$顺序存在$dfn[]$中,$rnk[]$则记录对应$dfn[]$对应的节点编号,这点千万不要搞错，尤其在单点操作时极其容易忽略 build函数 123456789101112 void build(int now,int l,int r)&#123;if(l==r)&#123; mx[now]=sum[now]=w[rnk[l]];//注意是rnk[l] return ;&#125;int mid=(l+r)&gt;&gt;1;build(now&lt;&lt;1,l,mid);build(now&lt;&lt;1|1,mid+1,r);sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]);return ; &#125; 必要的操作(一定要检查是否写了) 1234 dep[1]=1,fa[1]=0;//假设root是1dfs_1(1);dfs_2(1,1);build(1,1,n); 例题例题1： https://www.luogu.org/problemnew/show/P2590 代码:请戳这里 简要题解: 无 例题2: https://www.luogu.org/problemnew/show/P3384 代码: 请戳这里 简要题解: 无 例题3: https://www.luogu.org/problemnew/show/P3950 代码及题解: https://www.cnblogs.com/Rye-Catcher/p/9351619.html 例题4: https://www.luogu.org/problemnew/show/P4092#sub 这道题比较有意思，题解中找目标所在重链然后倍增的思路在今年NOI中可以运用 代码及题解: https://www.cnblogs.com/Rye-Catcher/p/9275770.html 例题5: 查了好久的错… https://www.luogu.org/problemnew/show/P2146 代码: 请戳这里 简要题解:区间覆盖]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtcoderSoundHound Inc.Contest解题报告]]></title>
    <url>%2F2018%2F07%2F07%2FAtcoderSoundHound-Inc-Contest%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[A C++ Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a+b==15)puts("+"); else if(a*b==15)puts("*"); else puts("x"); return 0;&#125; B C++ Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int maxn=100000;char str[maxn];int main()&#123; int w; scanf("%s",str); scanf("%d",&amp;w); if(w==1)&#123;printf("%s",str);return 0;&#125; for(int i=0;i&lt;strlen(str);i++)&#123; if(i%w==0)&#123; putchar(str[i]); &#125; &#125; return 0;&#125; C 这题画风突变啊喂 这题我比较SB打表没找出规律还是yjw学长点醒了我 $yjw$学长 $orz$ 这题其实是个概率题,长度为$m$,则最多有$m-1$对数字，显然每一对之间是互相不影响的,于是我们先来研究一对数字的情况： 首先每个数字都有n个数字与之配对，总计$n × n$种情况,再考虑对答案做贡献的，假设那一对数字是$x,y (y&gt;x)$,则能做贡献的情况有$n-d$种.当然我们这只是$x&lt;y$的情况，所以共$2×(n-d)$种。当然$d==0$时,就无关大小，只有$(n-d)$种，这需要特判. 然后交上去还是$WA$了,发现强制类型转换写在括号外导致会爆$int$,比较坑 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ri register int using namespace std;template &lt;class T&gt;void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125; int n,m,d;int main()&#123; read(n),read(m),read(d); if(d==0)printf("%.10Lf\n",(long double)(m-1)/n); else if(n&lt;=d)printf("0.0000000\n"); else printf("%.10Lf\n",(long double)(1.00*2*(n-d)*(m-1))/n/n); return 0;&#125; D 这题解法很有意思，比较考验智商 求两个最短路，一个是$s$到$x (x \in [1,n])$的用$yen$衡量的最短路$dis_1(s,x)$,一个是从$t$到$x (x \in [1,n])$的最短路$dis_2(t,x)$,用$snuuk$衡量的最短路 然后我们想，最后$n-1$年出发的时候只用$n$这个点可以交换货币，所以$val[n-1]=dis_1(s,n)+dis_2(t,n)$ 再向下想,在$n-2$年出发时,要么继续到$n$这个点交换货币，要么到$n-1$这个点交换货币，以此类推得到 $val[p]=min(val[p+1],dis_1(s,p)+dis_2(t,p)) p \in [0,n-1]$ 最后初始钱数$-val$值就是对应答案 E 我太菜不知道怎么做，等待咕咕咕的题解吧]]></content>
      <tags>
        <tag>比赛解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误笔记]]></title>
    <url>%2F2018%2F07%2F07%2F%E9%94%99%E8%AF%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[inf值要设大但不要溢出 vis之类的数组使用前都memset一下 memset一些除0外的奇怪的数字时，最好老老实实写for循环（谁叫我脸黑） edge数组不要设小了 C++ 11 不要用register int 手写堆中$heap[]$最好不用结构体，若用，手写swap函数 $bool$ $flag$一定要赋初值！！！！ 树链剖分注意https://www.cnblogs.com/Rye-Catcher/p/9265860.html 边权树上差分注意根节点不能算作贡献]]></content>
      <tags>
        <tag>错误笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APIO2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FAPIO2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0 上了下测试系统，发现居然是毛子的题（貌似系统也是，只给了英文和俄语两个选项），话说T1 A+B什么鬼。 然后向教父请假，教父一脸严肃好吓人，但是我能逃掉期中考hhhhhhhhh 在火车站等车居然看到两个师大的？ Day 1 早上五点多就被吵醒了，到了西客站后等了好久，然后又在宾馆等了好久，然后又背着大包走了好久，然后终于等到了房卡进了房间，话说房间真心不错（然而花的钱也很多） 下午模拟赛在Linux上，然而我$^{tm}$还不会用，VAN蛋，赶紧学了下命令行，自己琢磨GUIDE的字体大小弄了好久。 中午居然组队去吃饭？饭菜好评，按槽位自助打饭好评。接着回宾馆睡了一觉，下午发现可能要迟到了，一路跑过去，然后被一位武汉小哥告知根本没有模拟赛，只是上机？$qwq $ 虚拟机差评，键盘差评，时不时卡顿差评 然后到了实验楼的机房，自装NOI Linux好评，键盘好评，机子速度好评，然而位子这么挤不怕被偷屏吗… 将近五点，在中午食堂等开饭，等了好久被告知在另一个食堂？qwq Day 2 一大早被jyh拉起来到学校旁买本子，结果半天愣是没看到文具店？ 吃完早饭到正志厅准备听课。居然是wuhongxu?!然后一上来先水UOJ群，接着balabala讲起了折纸？！没错，就是折纸，计算机科学中的折纸。PPT全英文差评，看得好费劲，然后基本听不懂orz 然后折纸讲完了，whx比较兴奋地说：“现在我们讲图论中一些有趣的算法”。然而。。。基本听不懂orz,看到APSP(All Pair Shortest Path)各种神仙算法复杂度，和其中一个证明过程，这…orz 接着是秦岳讲课，泊松图像编辑和游戏中的AI，感觉挺有趣的，讲了一堆博弈算法orz 下午终于比较正经，wuvin讲二分，弹幕好评，不过一下就来了什么暴力%之类奇奇怪怪的东西…终于有能听懂的东西了，感动 然后是Kiana(这名字好熟悉啊，好像是哪年的noip还是noi题面中出现过)讲图的匹配…终于有能听懂的东西了，感动……然后讲到了三分图，我：？？？ 后面吃饭领密码条，好象和之前的一模一样 今天也算开拓了视野，JXOI2018 T1 的Gobo sort不是空穴来风，原来真有个叫Bogo sort(猴子排序)的玩意，顺便知晓了后天是PKU的大佬讲课，还知道了那个背着NOI 34th书包的居然是BJ A类队长,而且才初三orz感觉明天要爆0滚粗了… Day 3 上午考试一开始去错了考场真尴尬，居然是在办公楼？！居然还是虚拟机？！然后CCF的工作人员告诉我们只准钦定Linux，用Windows属于作弊（万一不小心按了win键呢） 然后在线看题，还是一样毛子的评测系统，中文翻译好评。T1目测毒瘤数据结构，可以暴力，“小明”是什么鬼？！T2 emmm又是圆，可以暴力 T3 目测图论，可以暴力。 然后我真的只交了暴力，T1，T2第一个Substask，T3第一个$n&lt;=10$的Substask 爆搜 TLE？！最后只得交一个n&lt;=1000 无环的判定，自己想出了一个比较玄学的方法，不知道能不能行。 正当我为我的机智沾沾自喜时，jyh说：不就一个DP.我：…woc好象真的是orz 然后是讲题，T1线段树分治?!什么东西？！T2K-D树？！什么东西？！T3圆方树？！什么东西。 猫锟：“87分的都是暴力没打好” “我翻译的时候就觉得题目太水了，不都是套路嘛” 我：orz 铁牌钦定 Day 4 上午以为8：30吃早饭，结果进入正志厅时老师已经讲课了。话说今天讲课的老师没听过，来的人也更少，是不是一些dalao都去THUPC了…话说我们学校连人都凑不齐… 上午讲数论函数相关，欧拉函数emmm欸我会….杜教筛….有道理 洲阁筛….wtf!? Min_25筛….wtf!? 然后就坐车去八十中，真远啊。 下午听后缀自动机…一下午属于离线状态……顺便打了一下平均边权最大的代码。蒟蒻的我字符串只会Hash(蛤xi) 然后是吃饭，我以为所有窗口饭菜都是一个样…然后就点到最烂的菜…根本没胃口 晚上等到了闭幕式，强行用笔记本为手机续命，一开始先是解释CTSC代码丢失的处理结果，不过对我这种辣鸡没能参加CTSC的选手没影响 然后开始讲APIO，原来这就是APIO的正式考试啊（话说我是不是唯一一个现在才知道的），难怪我这个蒟蒻觉得这么难 “感谢主办方提供实时评测，即时反馈”。。。全场响起了经久不绝的掌声 然后颁奖，中间还有段舞蹈。无疑打铁走人，师大一个高一的拿了Ag，太强了orz 总之第一次参加这样的活动，也学到不少东西，发现自己许多不足：模拟赛基本没打过，临考经验不足，该拿的部分分没拿到，还是要多多努力。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXOI2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FJXOI2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[—Update5.2 成绩出了，见后文 听说省选VAN写游记是传统，本蒟蒻也来发一篇吧。 DAY 0 本来以为省选不在JKFZ举行的结果又是在JKFZ，本校作战感觉终究会是好一些吧，和jyh一起向教父申请停了一天的课，没想到教父居然笑眯眯地答应了，有点出乎意料。 上午和jyh一起打了yjw学长Yali集训时的模拟赛，T1线段树，T2。。。 T3。。。然后愉快地打了线段树，结果。。。爆0。 中午吃完后dalao jyh讲了他T3思路，总之感觉很厉害。 下午dalao jyh写出T3果然是满分，orz。然后被教练拉去和yjw谈一谈赛前经验，然后莫名其妙就变成模拟赛题解讲解，原来T1爆0原因是因为&amp;和|运算不能简单地只是打个标记，我还是naive了。 晚上终于回家了，随便打了下模板，本来想开CSGO，结果偷偷玩了几把混乱大枪战后就睡了。 DAY 1 早上坐车来到JKFZ，打了几遍数论相关模板，连莫比乌斯这种不太会考的都打了一遍。 然而。。。 和jyh一起取考场的时候总是有些奇怪，但还算释然。上机试了下机子，除了键盘有些不适应之外还好没什么问题（一想到NOIP时机子打不开T盘就觉得好笑）。不久题目发了下来。 第一眼看到题面，九条可怜？woc又是吉如一出题。把全部PDF浏览后开始做T1，T1一开始看不懂在草稿纸上推了一遍后却觉得思路还挺容易。 T1大致题面：他先告诉你一个叫gobo sort的排序方法：对于一个成为n的序列a，随机生成另一个长为n序列p，然后构造一个长为n的序列b,使得$b_i$ $=$ $a_{p_i}$。假如这个b是有序的，则停止操作，排序完成，反之不断重复生成p序列的操作. 然后给你一个长为n的序列，和m,l,r。要求你在n长的序列后接上m个值域为[l,r]的数，使得gobo sort中随机生成序列的期望次数最多。 草稿纸上搞了一下发现你只要让每个数字出现的次数平均就好了。具体怎么算这里不再赘述，然而在考场上我发现有几个地方需要注意： 离散化 2.可以用堆维护 3.由于有阶乘，除和取模操作，需要逆元. 然而蛋疼的是我忘了逆元怎么打！！！在考场上手推好久，只得作罢，去做T2 T3 T2打了暴力，T3连暴力都不知道怎么打… 总之出了考场后很颓废，T1没打逆元，什么优化也没加，估计凉凉。 然后下午yjw学长搞来份solution，看了一下T1思路确时没错,T2用sigma推了一大堆结果时间复杂度只有O（r）?T3区间DP，好难根本想不到。 后面看了下逆元，发现原来这么容易求,考场上用费马小定理却没推出来…还是我太弱了。 DAY 懒得数了 五一节后成绩出来了，居然有50分，我想应该是T1 30+T2 20+T3 0瞄了一眼大多都是这个分段，然而我的NOIP只有120，前面都是200+或300+，我还是太蒻了,学长进了A类，不过有一个赣州中学高一省队爷，真的强…以及一位爆0 A队女选手。 然后在知乎上看到这个： 厚颜无耻的出题人 %%% 后记 总之还是意料之中吧，也恰恰反映我的不足，以后还是要多刷题，坚持在NOIP前一月把算法竞赛进阶指南刷完，（现在看怕是没机会了）争取考400+(这么弱怎么可能)。 总之应用一句在其他dalao滚粗记中的话吧： _一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程 。 ——长者_]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F07%2F07%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[Hello World 第一篇博客纪念 $ \mathcal{Enjoy Reading Here} $]]></content>
      <tags>
        <tag>Not Yet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
