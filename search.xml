<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ3884题解上帝与集合的正确用法--扩展欧拉定理]]></title>
    <url>%2F2018%2F07%2F28%2FBZOJ3884%E9%A2%98%E8%A7%A3%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=3884 分析 扩展欧拉定理裸题 欧拉定理及证明: 如果$(a,m)=1$,则$a^{\phi(m)} \equiv 1 \mod m$ $Prove:$设$x$取遍$m$的缩系,则$ax$取遍$m$的缩系,即 \prod x = \prod ax \mod m因为这样的$a$有$\phi(m)$个 \prod x = \prod x *a^{ \phi(m)} \mod m由于$(x,m)=1$,保证$\prod x$ 存在模$m$意义下的逆元 所以 a^{ \phi(m)} \equiv 1 \mod m 扩展欧拉定理: 如果 (a,m)!=1则 a^b \equiv a^{min(b,b \% \phi(m)+\phi(m))} \mod m 设$f(x)$为在模$x$意义下题目式子的值,那么f(x)=2^{2^{^{...}}\%\phi(x)+\phi(x)} \mod x=2^{f(\phi(x))+\phi(x)} \mod x 然后就可以记忆化搞一搞了 注意 求欧拉函数可以线性预处理也可以直接求,实践证明直接求不知道快到哪里去了 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using std::sort;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;const int maxn=10000005;const int inf=0x7fffffff;int t,n;int mem[maxn];int phi[maxn];bool vis[maxn];inline void get_table()&#123; bool is_pri[maxn]; int num[1000005],tot=0,tmp; memset(is_pri,0,sizeof(is_pri)); is_pri[1]=1; phi[1]=1; for(ri i=2;i&lt;=maxn;i++)&#123; //printf("%d\n",i); if(!is_pri[i])&#123; num[++tot]=i; phi[i]=i-1; &#125; for(ri j=1;j&lt;=tot;j++)&#123; tmp=num[j]*i; if(tmp&gt;=maxn)break; is_pri[tmp]=1; if(i%num[j]==0)&#123; phi[tmp]=num[j]*phi[i]; break; &#125; else &#123; phi[tmp]=(num[j]-1)*phi[i]; &#125; &#125; &#125; return ;&#125;inline int get_phi(int x)&#123; int res=x; for(ri i=2;i*i&lt;=n;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0)x=x/i; &#125; &#125; if(x&gt;1)res=res/x*(x-1); return res;&#125;int ksm(ll x,int c,int p)&#123; ll ans=1,res=x; while(c)&#123; if(c&amp;1)ans=ans*res%p; res=res*res%p; c=c&gt;&gt;1; &#125; return ans%p;&#125;int f(int x)&#123; if(x==1)return 0; if(vis[x])return mem[x]; int p=phi[x];//int p=get_phi(x); vis[x]=1; mem[x]=ksm(2,f(p)+p,x); return mem[x];&#125;int main()&#123; read(t); get_table(); while(t--)&#123; read(n); printf("%d\n",f(n)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>扩展欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--数论知识集合]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[前言 数论在OI中还是比较重要的,这些笔记是在课上匆忙记下的,可能不太美观。 一些约定:在这里整数间除法是向下取整;$(a,b)$代表$gcd(a,b)$ Problems: 小凯的疑惑 $sol$:构造 $ax+by = k(a,b &gt;= 0)$ 使其无解 设一组解$x1 \in [0,b-1] ,y1&gt;=0$ 若$k&gt;ab-a-b$ 则$y1&gt;(k-a*x1)/b = (ab-a-b-a(b-1))/b $ $= -1$ 即$y1&gt;=0$ 故$k=ab-a-b$是符合条件的最大值 上帝与集合的正确用法—扩展欧拉定理 https://www.lydsy.com/JudgeOnline/problem.php?id=3884 屠龙勇士—扩展中国剩余定理 用$f(i)$表示有序三元组(a,b,c)个数,使得$abc=i$,求出$f(1)$~$f(n)$ $sol: i=\prod {p_i}^{c_i} $ $ f(i)=\prod C^{ci+2}_2$ 使用扩展欧拉筛 数论之神 Algorithms: 线性推逆元: $inv[fac[i]] = inv[fac[i+1]]*(i+1)$ 设$p=i*k+r$ $i*k+r \equiv 0 \mod p$ $i*k \equiv -r \mod p$ $r^{-1}*k \equiv -i^{-1} \mod p$ $i^{-1} \equiv -p/i*inv[p \% i]$ $\mod p$ 中国剩余定理 ExCRT(增量法):若m不互质 $x \equiv a \mod b -&gt; x=kb+a $ $x \equiv c \mod d -&gt; kb+a \equiv c \mod d -&gt; kb+pd = c-a$ 条件$(c-a)|gcd(b,d)$ 求解后回代即可 埃式筛 欧拉筛-扩展 (未懂) Miller-Rabin(未懂) 费马小定理&amp;&amp;二次剩余 Pollard-Rho(未懂) 生日攻击 类欧几里得算法(未懂) ​ https://www.cnblogs.com/LLppdd/p/8428349.html BSGS&amp;&amp;ExBSGS Other Things: $\sum_{i=1}^N {1/i} = O(log N)$ Prove: 下界 1/2 * log N $\sum_{i=1}^N {1/i} &gt;= 1+1/2+1/4+1/4+1/8+1/8+1/8+1/8+…$ 上界 log N $ \sum_{i=1}^N {1/i}&lt;=1+1/2+1/2+1/4+1/4+1/4+1/4+…$ $\sum{1/p} = O(log log N)$ 裴蜀定理: $(a,b)|d $ is equal to $ua+vb=d(u,v \in Z)$ $扩展欧几里得Exgcd:$ $a \mod b = a-a/b*b$ $ua+vb = gcd(a,b)$ $u’b+v’(a mod b) = gcd(a,b)$ $u’b+v’(a-a/b*b) = gcd(a,b)$ $v’a+(u’-a/b $ $v’)b = gcd(a,b)$ 通解:$x_0=x+tb/(a,b) $ $y_0=y-ta/(a,b)$ 一个小性质 $(k,m)=d$ $且$ $ka \equiv kb \mod m 则 a \equiv b \mod m/d$ $Prove: ka \equiv kb \mod m -&gt; m|(ka-kb) -&gt; m|k(a-b) -&gt; (m/d)|(a-b)$ 简化剩余系 所有$0&lt;n&lt;=m,(n,m)=1​$的n构成了模m的简化剩余系，简称缩系 记这样n的个数为$ \phi(m)$ 如果$(m,m’)=1$,$a$取遍模$m$缩系,$a’$取遍m’缩系 那么$am’+a’m$取遍$mm’$缩系 $Prove: 已知(a,m)=1,(a’,m’)=1 , (m,m’)=1$ $(am’,m)=1,(a’m,m’)=1$ $(am’+a’m,m)=1,(a’m+am’,m’)=1$ //加上另一个数的若干倍仍互质 $(am’+a’m,mm’)=1$ 所以如果$(n,m)=1,\phi(nm)=\phi(n)*\phi(m)$ $phi(p^e)=(p-1)$ $p^{e-1}=p^e(1-1/p) $ p是质数 $Prove: [1,p^e]中与p不互质的数的个数为p^e/p=p^{e-1}$$\phi(p^e)=p^e-p^{e-1} =p^e*(1-1/p)$ 计算公式:$\phi(p)= \prod \phi(p_i^{c_i}) = \prod (p^c_i $ $(1-1/p_i)) = n \prod (1-1/p_i)$ 欧拉定理 如果$(a,m)=1,a^{phi(m)} \equiv 1 \mod m$ $Prove: $设x取遍m的缩系,则ax取遍m的缩系 $ \prod x = \prod ax \mod m$ $\prod x = \prod x *a^{ \phi(m)} \mod m $ //这样的a有phi(m)个 由于$(x,m)=1$,保证$\prod x $存在模m意义下的逆元 所以 $a^{ \phi(m)} \equiv 1 \mod m$ 费马小定理 如果$(a,m)=1$,且m是个质数 $a^{m-1} \equiv 1 \mod m $ 扩展欧拉定理 如果$(a,m)!=1 $ 则 $a^b \equiv a^{min(b,b \% \phi(m)+\phi(m))} \mod m$ 阶如果(a,m)那么最小的正整数使得$a^{x} \equiv 1 \mod m$,x称为a模m的阶性质:$x|\phi(m)$Prove: 咕咕咕 原根 如果g在模m的阶是$\phi(m)$,那么称g是模m的原根 积性函数 欧拉函数，莫比乌斯函数，除数函数 狄利克雷卷积 满足交换律结合律分配律,可用倍增 $(f$ $g)(n) = \sum_{d|n} f(d)g(n/d)$ 如果f,g是积性函数,f*g也是积性函数 $f*e=f$ 单位元:e $e(1)=1$,其他$e(i)=0$; 莫比乌斯函数 $e(n)=\sum_{d|n}\mu(d)$ Prove:转化为二项式系数后转化 性质: $e(n)=\mu(n)*1$ 莫比乌斯反演 若$f(n)=\sum_{d|n} g(d)$ 则$g(n)=\sum_{d|n} \mu(d) f(n/d)$ $Prove:​$ $f = g1$ $\mu1 = e$ $f $$\mu = g $ 1$*\mu$ $f\mu$ $= ge$ $g=f*\mu $ -&gt; $g(n)= \sum_{d|n} \mu(d) f(n/d)$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--简化剩余系与欧拉函数]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%80%E5%8C%96%E5%89%A9%E4%BD%99%E7%B3%BB%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是简化剩余系？ _所有$0&lt;n&lt;=m,(n,m)=1$的n构成了模m的简化剩余系，简称缩系_ 记这样n的个数为$ \phi(m)$ 相关性质 如果$(m,m’)=1$,$a$取遍模$m$缩系,$a’$取遍m’缩系那么$am’+a’m$取遍$mm’$缩系 - $Prove: 已知(a,m)=1,(a&#39;,m&#39;)=1 , (m,m&#39;)=1$ $(am&#39;,m)=1,(a&#39;m,m&#39;)=1$ $(am&#39;+a&#39;m,m)=1,(a&#39;m+am&#39;,m&#39;)=1$ //加上另一个数的若干倍仍互质 $(am&#39;+a&#39;m,mm&#39;)=1$ - 所以如果$(n,m)=1,\phi(nm)=\phi(n)*\phi(m)$ $\phi(p^e)=(p-1)p^{e-1}=p^e(1-1/p) $ p是质数 $Prove: [1,p^e]中与p不互质的数的个数为p^e/p=p^{e-1}$ $\phi(p^e)=p^e-p^{e-1} =p^e*(1-1/p)$ 特殊地,若$p$是一个质数,则$\phi(p)=p-1$ 什么是欧拉函数 _在数论，对正整数$n$，欧拉函数是小于或等于$n$的数中与$n$互质的数的数目。欧拉函数用希腊字母$phi()$或$\phi()$ （念fai去声）表示，$phi(n)$表示正整数n的欧拉函数。_ 举个栗子：$[1,12]$中与$12$互质的有$1,5,7,11$。 (别忘了，$a$与$b$互质表示$gcd(a,b)=1$，故1也算) 所以$\phi(12)=4$。 很显然这个$\phi(m)$就是上文简化剩余系中所提到的 欧拉函数的计算由上文简化剩余系的性质可知 计算公式:$\phi(p)= \prod \phi(p_i^{c_i}) = \prod (p^c_i (1-1/p_i)) = n \prod (1-1/p_i)$ 计算方式直接按照定义 12345678910111213int euler_phi(int n)&#123; int m=(int)sqrt(n+0.5); int ans=n; for(register int i=2;i&lt;=m;i++) if(n%i==0) &#123;//最好要先除后乘，防止结果溢出 ans=ans/i*(i-1); //上文推导得 while(n%i==0)n=n/i;//将n中所有因子i筛去 //确保下一个i是n的质因子 &#125; if(n&gt;1)ans=ans/n*(n-1);//防止n为最后一个质因子 return ans;&#125; 例题： hdu 1787裸欧拉函数简单变式 有没有$O(N)$预处理出一张欧拉函数表的方法呢？当然有,在欧拉筛的基础上稍加改动即可，想要看懂代码请您先熟练欧拉筛 这是一个欧拉筛 12345678910111213141516void Euler_Prime() &#123; memset(is_Prime,1,sizeof(is_Prime)); memset(pri,0,sizeof(pri)); is_Prime[0]=0; is_Prime[1]=0;//特判 for(register int i=2;i&lt;=n;i++) &#123; if(is_Prime[i]) pri[tot++]=i; //----1 for(register int j=0; j&lt;tot &amp;&amp; i*pri[j]&lt;=n;j++)&#123; is_Prime[i*pri[j]]=0; if(i%pri[j]==0) break; //-----2 //-----3 &#125; &#125; &#125; 使用欧拉筛时无非在代码中$1,2,3$处三种情况: （话说第二条的证明找了挺久，好多人都直接略过，感觉我真的太菜了 判定$i$是一个质数,根据上文性质$\phi(i)=i-1$ 在2处,$\phi(ipri[j])=\phi(i)pri[j]$ $Prove:$设$x=pri[j]*i$,易知此时$i$包含$pri[j]$这个质因子,即$i$的质因子与$x$的相同,根据欧拉函数的直接计算方式, $\phi(x)=x \prod (1-1/p_i)=pri[j]i \prod (1-1/p_i)= pri[j]\phi(i)$ 在3处,易知$i$与$pri[j]$互质,根据欧拉函数性质(也是积性函数性质) $\phi(x) = \phi(i)\phi(pri[j]) = \phi(i) (pri[j]-1)$ 然后就可以看懂代码了 123456789101112131415161718192021222324252627inline void get_phitable()&#123; bool is_pri[maxn]; int num[1000005],tot=0,tmp; memset(is_pri,0,sizeof(is_pri)); is_pri[1]=1; phi[1]=1; for(ri i=2;i&lt;=maxn;i++)&#123; //printf("%d\n",i); if(!is_pri[i])&#123; num[++tot]=i; phi[i]=i-1; &#125; for(ri j=1;j&lt;=tot;j++)&#123; tmp=num[j]*i; if(tmp&gt;=maxn)break; is_pri[tmp]=1; if(i%num[j]==0)&#123; phi[tmp]=num[j]*phi[i]; break; &#125; else &#123; phi[tmp]=(num[j]-1)*phi[i]; &#125; &#125; &#125; return ;&#125; 推荐阅读]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>欧拉函数与简化剩余系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2312解方程--暴力膜+秦九韶]]></title>
    <url>%2F2018%2F07%2F27%2Fluogu%E9%A2%98%E8%A7%A3P2312%E8%A7%A3%E6%96%B9%E7%A8%8B-%E6%9A%B4%E5%8A%9B%E8%86%9C-%E7%A7%A6%E4%B9%9D%E9%9F%B6%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P2312 分析 这道题很毒啊,这么大的数。 但是如果多项式$\sum_{i=0}^N a[i]X^i=0$则$\sum_{i=0}^N a[i]X^i \mod P=0$ 于是我们可以暴力膜一模，然后在$[1,m]$中枚举就好了。但是呢，万一这个多项式的值是$P$的倍数,也会变成0，所以保险起见搞几个又大又质的数膜一膜就好了。 但是$Exciting$的是呢,我在洛谷上开O2能过，而BZOJ就不那么友好。 然后luogu题解提供一种减少枚举冗杂的方Fa。我们不是选多个数膜一模吗，如果在膜$P_i$的意义下已经不是$0$了,枚举其他的就没意义了。于是呢，我们先可以选出一个小点的模数$P_x$，在$[1,P_x]$中先枚举一遍，记录多项式值为0的是哪些。最后再枚举$[1,m]$，由于先前的限制，就会减少许多无用选择 然后多项式求值有个叫秦九韶算法的$O(N)$方法,不了解的可以看一看 https://www.cnblogs.com/Rye-Catcher/p/9260599.html 代码 我选择了两个数来做模数，较小的是23333，较大的是19260817 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define ll long long #define ri register int using namespace std;const int maxn=105;const int inf=0x7fffffff;const int p1=19260817,p2=71806291,p3=23333;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return ;&#125;int n,m;ll a[maxn],c[maxn];inline void input(int id)&#123; a[id]=c[id]=0;int ne=0;char ch; while(!isdigit(ch=getchar()))ne=ch=='-'; a[id]=c[id]=ch-48; while(isdigit(ch=getchar()))&#123; a[id]=((a[id]&lt;&lt;3)%p1+(a[id]&lt;&lt;1)+ch-48)%p1; c[id]=((c[id]&lt;&lt;3)%p3+(c[id]&lt;&lt;1)+ch-48)%p3; &#125; a[id]=ne?-a[id]:a[id]; c[id]=ne?-c[id]:c[id];return ;&#125;int ans[1000005],tot=0;bool ok[1000005];inline bool pre_calc(ll u)&#123; ll x=0; for(ri i=n;i&gt;=0;i--)&#123; x=(x*u+c[i])%p3; &#125; return x==0?1:0;&#125;inline bool calc(ll u)&#123; ll x=0; for(ri i=n;i&gt;=0;i--)&#123; x=(x*u+a[i])%p1; &#125; return x==0?1:0;&#125;int main()&#123; read(n),read(m); for(ri i=0;i&lt;=n;i++)&#123; input(i); &#125; memset(ok,0,sizeof(ok)); for(ri i=1;i&lt;=p3;i++)&#123; if(pre_calc(1ll*i))ok[i]=1; &#125; for(ri i=1;i&lt;=m;i++) if(ok[i%p3]&amp;&amp;calc(1ll*i))&#123; ans[++tot]=i; &#125; printf("%d\n",tot); for(ri i=1;i&lt;=tot;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5017炸弹题解--玄学递推]]></title>
    <url>%2F2018%2F07%2F27%2FBZOJ5017%E7%82%B8%E5%BC%B9%E9%A2%98%E8%A7%A3-%E7%8E%84%E5%AD%A6%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=5017 分析 老师讲课谈到了这道题，课上想出了个连边建图然后乱搞的操作，被老师钦定的递推方法枪毙了；晚上回去做了做，好像复杂度是不对。还是学习了下此题递推方法，感觉考场上写这个的是抱着得部分分的心理A了这道题(话说洛谷没有SNOI2017的题目 我们用$l[i],r[i]$表示$i$最左和最右能拓展到的炸弹编号,初始化$l[i]=r[i]=i$,$rr[i]$表示$i$最大的爆炸半径(因为它可能会随着$l[i],r[i]$更新而更新) 然后就递推了.求$l[i]$,如果$x[i]-x[l[i]-1]&lt;=rr[i]$则拓展，同时检查是否更新$rr[i]$;求$r[i]$类似。 时间复杂度我也很懵，感觉应该有个均摊值,老师课上讲拓展次数不会超过$log N$感觉不太对啊。。。 同时这题有个线段树优化建边+Tarjan缩点+拓扑排序后DP的方法 注意 $l[i]$是向左拓展,故从$1$递推到$N$; $r[i]$就要从$N$递推到$1$. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;const int maxn=500000;const int inf=0x7fffffff;int n;ll l[maxn],r[maxn],x[maxn],rr[maxn];ll ans=0;int main()&#123; read(n); for(ri i=1;i&lt;=n;i++)&#123; read(x[i]),read(rr[i]); l[i]=r[i]=i; &#125; for(ri i=1;i&lt;=n;i++)&#123; while(l[i]&gt;1&amp;&amp;x[i]-x[l[i]-1]&lt;=rr[i])&#123; l[i]=l[l[i]-1],rr[i]=max(rr[i],rr[l[i]]-(x[i]-x[l[i]])); &#125; &#125; for(ri i=n;i&gt;=1;i--)&#123; while(r[i]&lt;n&amp;&amp;x[r[i]+1]-x[i]&lt;=rr[i])&#123; r[i]=r[r[i]+1],l[i]=min(l[i],l[r[i]]); &#125; ans=(ans+1ll*i*(r[i]-l[i]+1))%1000000007; &#125; printf("%lld\n",ans); return 0;&#125; 推荐学习博客 https://blog.csdn.net/c_k_y_/article/details/79980119 https://blog.csdn.net/Icefox_zhx/article/details/78877188]]></content>
      <tags>
        <tag>题解</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P3950部落冲突--树链剖分]]></title>
    <url>%2F2018%2F07%2F27%2Fluogu%E9%A2%98%E8%A7%A3P3950%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/P3950 分析 大佬都用LCT，我太弱只会树链剖分 一个很裸的维护边权树链剖分题.按照套路,对于一条边$(dep(u)&lt;dep(v))$,让它边权加1就在$v$点处+1，将边的问题转化为点的问题 然后对于C，U操作，线段树单点修改，Q操作区间查询 注意 询问$u,v(dep(u)&gt;dep(v))$点之间是否联通区间查询时注意是查询$[u,son[v]]$的和,忽然发现NOI赛场上Day2用树链剖分写得暴力为什么错了。。。 单点修改注意是修改$dfn[x]$那个点,查了好久的错 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define ll long long #define ri register intusing namespace std;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x;return;&#125; const int maxn=300005;const int inf=0x7fffffff;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=1;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge;&#125;int dfn[maxn],tot=0,top[maxn],dep[maxn],fa[maxn],son[maxn],size[maxn];void dfs_1(int now)&#123; int v;size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v;dfn[now]=++tot,top[now]=t; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;int sum[maxn&lt;&lt;2],L,R,dta,t;void update(int now,int l,int r)&#123; if(l==r)&#123; sum[now]+=dta; return ; &#125; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(now&lt;&lt;1,l,mid); else update(now&lt;&lt;1|1,mid+1,r); sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; return ;&#125;int query(int now,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[now]; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=query(now&lt;&lt;1,l,mid); if(mid&lt;R)ans+=query(now&lt;&lt;1|1,mid+1,r); //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;ans&lt;&lt;endl; return ans;&#125;int n,m;struct War&#123; int x,y;&#125;war[maxn];int query_path(int x,int y)&#123; int tmp=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); L=dfn[top[x]],R=dfn[x]; tmp=query(1,1,n); //cout&lt;&lt;tmp&lt;&lt;endl; if(tmp!=0)return 0; x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); L=dfn[x]+1,R=dfn[y]; if(L&gt;R)return 1; tmp=query(1,1,n);//puts("f***"); //cout&lt;&lt;tmp&lt;&lt;endl; if(tmp!=0)return 0; return 1;&#125;inline void update_path(int x,int y,int z)&#123; dta=z; if(dep[x]&lt;dep[y])swap(x,y); t=dfn[x]; update(1,1,n); //L=1,R=n; //printf("%d\n",query(1,1,n)); return ;&#125;int main()&#123; char opt[5]; int x,y,z,cnt=0; read(n),read(m); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; dep[1]=1,fa[1]=0; dfs_1(1); dfs_2(1,1); memset(sum,0,sizeof(sum)); for(ri i=1;i&lt;=m;i++)&#123; scanf("%s",opt); if(opt[0]=='Q')&#123; read(x),read(y); if(query_path(x,y))puts("Yes"); else puts("No"); &#125; else if(opt[0]=='C')&#123; read(x),read(y); war[++cnt].x=x; war[cnt].y=y; update_path(x,y,1); &#125; else&#123; read(z); x=war[z].x,y=war[z].y; update_path(x,y,-1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11987Almost Union-Find题解--并查集的删除]]></title>
    <url>%2F2018%2F07%2F27%2FUVA11987Almost-Union-Find%E9%A2%98%E8%A7%A3-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.luogu.org/problemnew/show/UVA11987 分析 分析下操作发现就是加了个删除操作的并查集,怎么做删除操作呢. 我们用一个$id[]$记录每个数字在并查集中的编号,$tot=n$,一开始$id[i]=i$,当将$p$从原集合中删除时,让原来的$id[p]$变成一个虚点,$id[p]=++tot$,这样就完成了删除操作，当然我们查找祖先时需要$find(id[x])$ 推荐博客:https://blog.csdn.net/grimcake/article/details/77115078 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define ll long long #define ri register int using namespace std;const int maxn=200005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int size[maxn],id[maxn],sum[maxn],fa[maxn],tot=0;int find(int x)&#123; return fa[x]==x?fa[x]:fa[x]=find(fa[x]);&#125;int n,m;int main()&#123; int opt,p,q,x,y; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; tot=n; for(ri i=1;i&lt;=n;i++)&#123; size[i]=1; fa[i]=id[i]=sum[i]=i; &#125; while(m--)&#123; read(opt); if(opt==1)&#123; read(p),read(q); p=find(id[p]),q=find(id[q]); if(p==q)continue; fa[p]=q; sum[q]+=sum[p]; size[q]+=size[p]; &#125; else if(opt==2)&#123; read(p),read(q); x=find(id[p]),y=find(id[q]); if(p==q)continue; id[p]=++tot; fa[id[p]]=y; sum[y]+=p,size[y]++; size[x]--,sum[x]-=p; &#125; else&#123; read(p); x=find(id[p]); printf("%d %d\n",size[x],sum[x]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4887可乐题解--矩阵运算]]></title>
    <url>%2F2018%2F07%2F27%2FBZOJ4887%E5%8F%AF%E4%B9%90%E9%A2%98%E8%A7%A3-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=4887 分析 话说这道题经常见到类似模型来计数算期望,概率啊,然而我太蒻了都不会做,今天看到这题的第一个题解感觉真妙啊 我们构建邻接矩阵$A$,$a[i][j]=1$表示i到j状态有连接的边。 如果有一条边连接$u,v$则$a[u][v]=1$且$a[v][u]=1$ $a[i][i]=1$表示停在原地 再构建一个虚点0,$a[i][0]=1$表示自爆事件,完美满足题目要求 统计$\sum_{i=0}^{N}A[1][i]$就是答案 然而这题BZOJ AC 洛谷 WA 不知道怎么回事 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define ll long long #define ri register int using namespace std;const int maxn=35;const int maxm=105;const int inf=0x7ffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,m,t; struct Mat&#123; int mat[maxn][maxn]; Mat()&#123;memset(mat,0,sizeof(mat));&#125; Mat(int x)&#123;for(ri i=0;i&lt;=n;i++)mat[i][i]=x;&#125; Mat operator *(const Mat &amp;b)const &#123; Mat ans; for(ri i=0;i&lt;=n;i++)&#123; for(ri j=0;j&lt;=n;j++)&#123; for(ri k=0;k&lt;=n;k++)&#123; ans.mat[i][j]+=mat[i][k]*b.mat[k][j]%2017; &#125; &#125; &#125; return ans; &#125; Mat operator ^(const int &amp; C)const &#123; Mat ans=Mat(1),res=*this;int c=C; while(c)&#123; if(c&amp;1)ans=ans*res; res=res*res; c=c&gt;&gt;1; &#125; return ans; &#125;&#125;a;int main()&#123; int x,y,ans=0; read(n),read(m); for(ri i=0;i&lt;=n;i++)&#123; a.mat[i][0]=1; a.mat[i][i]=1; &#125; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); a.mat[x][y]=a.mat[y][x]=1; &#125; read(t); a=a^t; for(ri i=0;i&lt;=n;i++)ans+=a.mat[1][i]%2017; printf("%d\n",ans%2017); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>矩阵</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4241题解历史研究--回滚莫队]]></title>
    <url>%2F2018%2F07%2F16%2FBZOJ4241%E9%A2%98%E8%A7%A3%E5%8E%86%E5%8F%B2%E7%A0%94%E7%A9%B6-%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=4241 分析 这题就是求区间权值乘以权值出现次数的最大值,一看莫队法块可搞,但仔细想想,莫队的加入很容易,但是删除需要维护许多东西,非常麻烦,于是就有dalao想出了一个新科技—回滚莫队.回滚莫队能使操作全部变成加入或全部变成删除.这道题我们需要全部变成加入. 怎么做呢？我们对询问进行处理,左端点在一个块中的先归在一起,然后以右端点为关键字进行排序,使得右端点靠前的在前.然后依次处理按左端点归好后每个块中的询问,我们找到块中最靠后的左端点,和最靠前的右端点(其实就是块中第一个询问的右端点),统计区间信息。 对于每一个询问,先移动右端点加入元素,然后左端点左移得到询问答案后再向右移撤销,由于不需要维护什么信息撤销变得非常容易.简单来说,总的思路就是先找出最“窄”的区间,然后不断加入补全到询问区间. 当然,如果询问的左端点和右端点在一个块中就直接暴力处理 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;#define LL long long #define ri register int using std::min;using std::max;using std::vector;using std::map;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;x=ne?-x:x; return ;&#125;struct Qur&#123; int l,r,id; Qur(int a,int b,int c)&#123;l=a,r=b,id=c;&#125; bool operator &lt;(const Qur &amp; b)const &#123; return r&lt;b.r; &#125;&#125;;const int maxn=100005;const int maxb=355;const int inf=0x7fffffff;int n,w[maxn],pos[maxn];int blo,mxl[maxb];map &lt;int,int&gt; g;int tot=0,f[maxn];int cnt[maxn];LL res=inf,ans[maxn];vector &lt;Qur&gt; qry[maxb];inline void add(int x)&#123; cnt[x]++; res=max(res,1ll*cnt[x]*f[x]);&#125;int main()&#123; int l,r,q; read(n);read(q); blo=sqrt(n+0.5); memset(mxl,0,sizeof(mxl)); for(ri i=1;i&lt;=n;i++)&#123; read(w[i]); if(!g[w[i]])&#123; g[w[i]]=++tot; f[tot]=w[i]; &#125;w[i]=g[w[i]]; pos[i]=(i-1)/blo+1; &#125; for(ri i=1;i&lt;=q;i++)&#123; read(l),read(r); if(pos[l]==pos[r])&#123;//左端点右端点在一个块中 res=-inf; memset(cnt,0,sizeof(cnt)); for(ri j=l;j&lt;=r;j++)add(w[j]); for(ri j=l;j&lt;=r;j++)cnt[j]--; ans[i]=res; &#125; else&#123; qry[pos[l]].push_back(Qur(l,r,i)); mxl[pos[l]]=max(mxl[pos[l]],l);//记录询问块中的最后左端点 &#125; &#125; int ll,rr;LL last; for(ri i=1;i&lt;=pos[n];i++)&#123;//处理每个询问块 if(qry[i].empty())continue; memset(cnt,0,sizeof(cnt));res=-inf; sort(qry[i].begin(),qry[i].end()); l=mxl[i],r=qry[i][0].r; for(ri j=l;j&lt;=r;j++)add(w[j]); for(ri j=0;j&lt;qry[i].size();j++)&#123; ll=qry[i][j].l,rr=qry[i][j].r; while(r&lt;rr)r++,add(w[r]); last=res;//记录下右端点操作后信息 for(ri k=ll;k&lt;l;k++)add(w[k]); ans[qry[i][j].id]=res,res=last;//左端点左移后撤回 for(ri k=ll;k&lt;l;k++)cnt[w[k]]--;//已经得到答案,撤回非常容易 &#125; &#125; for(ri i=1;i&lt;=q;i++)printf("%lld\n",ans[i]); return 0;&#125; 后记 关于这题的离散化处理,我还进行了一些比较,在这篇博客中 https://rye-catcher.github.io/2018/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F/ 推荐学习博客 http://isrothy.blog.uoj.ac/blog/3673]]></content>
      <tags>
        <tag>题解</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2659算不出的算式不正经题解]]></title>
    <url>%2F2018%2F07%2F15%2FBZOJ2659%E7%AE%97%E4%B8%8D%E5%87%BA%E7%9A%84%E7%AE%97%E5%BC%8F%E4%B8%8D%E6%AD%A3%E7%BB%8F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目链接 https://www.lydsy.com/JudgeOnline/problem.php?id=2659 分析 难得做到此类打表题目,不觉回想到NOIp2017考场上的SB经历 这道题看到这么吓人的算式,当然是要…. 咳咳,像我这种菜鸡当然是先要打个表 好象没什么规律,但我们可以找找特殊项 比如(3,3)和(5,5),(7,7),大胆猜想若两数相同对于奇质数$x$，$ans=(x*x-1)/4$ 然后就往4方面去想,把所有答案乘以4得到另一张表,然后就很容易发现规律了 ans= \begin{cases} p*q/4& \text{p=q}\\ (p-1)*(q-1)/4& \text{p!=q} \end{cases}证明 数竞队的还没有回应, 不过在网上找到一篇不错的 https://www.cnblogs.com/Mychael/p/9115847.html 个人觉得讲得比其他blog好一点 代码 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define ll long long #define ri register int const int maxn=100005;const int inf=0x7fffffff; int main()&#123; int a,b; scanf("%d %d",&amp;a,&amp;b); if(a==b)printf("%lld\n",1ll*a*b/4); else printf("%lld\n",1ll*(a-1)*(b-1)/4); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--几种离散化方式]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 在OI学习过程中,我们常常会发现一些题目(尤其数据结构题)中,一些数据的范围很大,但是涉及的数值的个数却很少,同时我们想用一个数组的下标与这些数据建立一一对应关系,这时我们就需要离散化 大致思路 对于一个大小为$N$不含重复数字的数组$a[N] (a[i]&lt;=10^9)$,我们可以将$a[]$中的N个整数与$1$ ~ $N$这$N$构成一一映射关系,也就是说把$a[i]$用一个$1$~$N$中的数字代替,这样空间和时间复杂度都能变成与$N$相关 当然如果数组中有重复数据,你需要先去重(使用$std::unique$等)再进行上述操作 方式 结构体+$sort$ 对于大小为$N$不含重复数据的整型数组$a[N]$,定义结构体 1234struct Data&#123; int x;//原数组中的数据 int id;//原数组中储存x的下标&#125;d[N]; 然后以$x$为关键字进行排序,进行以下操作 1234sort(d+1,d+1+N);//假设从1开始for(int i=1;i&lt;=n;i++)&#123; a[d[i].id]=i;//按大小顺序离散化&#125; 时间复杂度$O(NlogN)$ 空间复杂度$O(N)$ 但是,使用这种方式的前提是数组无重复数据 $sort$+$lower $_$bound$ 这应该是最常见的离散化方式 您只需要知道对于大小为$N$的数组$a[]$, $lower $_$bound(a+1,a+1+N,X)-a$返回$a$中第一个大于等于X的位置 $unique(a+1,a+1+n)-(a+1)$返回将$a$数组去重后$a$的数组大小 然后就不难理解下面代码 123456789for(int i=1;i&lt;=N;i++)&#123;scanf("%d",&amp;a[i]);f[i]=a[i];&#125;sort(f+1,f+1+N);int nn=unique(f+1,f+1+N)-(f+1);//去重for(int i=1;i&lt;=N;i++)&#123;a[i]=lower_bound(f+1,f+1+nn,a[i])-f;&#125; 这样$f[i]$储存了从小到大排序后原来$a$中所有元素,$a[i]$中就储存了按大小排序后,原本$a[i]$大小的排名,$f[ \ a[i] \ ]$则返回原本$a[i]$的值 $map\&amp;unordered $_$map$ 如果您不知道STL中的$map$,建议您先去了解再来看此篇文章 其实思路很$naive$,知道$map$用法的应该都能看懂 12345678910map &lt;int,int&gt; g;int a[N],f[N],tot=0;for(int i=1;i&lt;=N;i++)&#123; scanf("%d",&amp;a[i]); if(!g[a[i]])&#123; g[a[i]]=++tot; f[tot]=a[i]; &#125; a[i]=g[a[i]];&#125; $f[a[i]]$就是原数组$a[i]$的值 但是$map$是用红黑树实现的,储存的元素是有序的 而$unordered $_$map$是用哈希表实现的 而在这里$map$纯粹只是起到了$hash$的查找与赋值,用$unordered$_$map$也能实现,相比较之下一般会更$unordered$_$map$快一点(实际上您可以手写一个哈希表完成上面的离散化操作) 然而使用$unordered$_$map$时注意,$C++11$之前使用需要 1234#include &lt;tr1/unordered_map&gt;using namespace std;using namespace std::tr1;unordered_map &lt;int,int&gt;g; $C++ 11$之后则可以使用 123#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int,int&gt;g; $pb$_$ds$中的$hash$_$table$ $pb$_$ds$中有许多黑科技,您可以在这篇博客中了解: https://blog.csdn.net/Only_AiR/article/details/51940500 其中就有个$hash$_$table$，顾名思义,就是个蛤希表了,可以只用$find()$和$operator[]$,十分方便 然而使用它需要记一点东西,但你问我资不资瓷，当然是资瓷啊 12345#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;cc_hash_table &lt;int,int&gt;g1;//两种hash_table,都跑得和香港记者一样快gp_hash_table &lt;int,int&gt;g2; 后记 话说写这篇博客还是因为这道题 https://www.lydsy.com/JudgeOnline/problem.php?id=4241 我调整各种离散化方式来看看哪个最快,同时在luogu的个人私题中同步测试 然后给大家看看时间比较(因为怕影响大家评测把时间限制开的很小,难免会TLE,$bzoj$时限是80s) $hash $_$table$不知道高到哪里去 然而戏剧性的是BZOJ 上我测出来是$map$最快!!! $18000+ms$ 其余的都比裸$map$慢了近$1000$~$2000+$ $ \ $ $ms$ 很奇怪,BZOJ评测鸭太玄学了,如果有谁知道原因的可以解释下谢谢]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--Tarjan算法之割点与桥]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tarjan%E7%AE%97%E6%B3%95%E4%B9%8B%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[前言 图论中联通性相关问题往往会牵扯到无向图的割点与桥或是下一篇博客会讲的强连通分量,强有力的$Tarjan$算法能在$O(n)$的时间找到割点与桥 定义 若您是第一次了解$Tarjan$算法，建议您反复阅读定义,借助图像来理解 桥与割边 对于无向连通图中点集的一个节点$x$,删去节点$x$及其关联的边之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的割点 对于无向联通图中边集的一条边$e$,删去边$e$之后,存在一对不联通的点对$(a,b)$,则称$x$是这个无向图的桥或割边 对于一般无向图,割点和桥可以指各个联通块的割点和桥 时间戳: 在对图的$DFS$中,按照节点第一次被访问的顺序,给各个节点标记一个值,该值称为时间戳,我们用$dfn[x]$表示$x$的时间戳 搜索树 在对图的$DFS$中,由于每个点只会被搜一次,所以访问经过的边构成了一棵树,称为搜索树,各个节点为根的子树称为$subtree(x)$,注意,$x \in subtree(x)$ 追溯值 这个可以说是$Tarjan$算法的精髓了,在我个人看来,节点$x$的追溯值是指不经搜索树所能到达的所有节点中其时间戳的最小值或者它自身的时间戳. 这看起来很难得到各个节点的追溯值,实则不然,分析一下,节点$x$的追溯值可以在一遍$DFS$中求得,请看下文介绍 算法 性质一: 桥边都是搜索树上的边 反证法,若桥边不是搜索树上的边,断掉这条之后仍可通过搜索树上的边保持图的联通 割边判定法则 无向边$(x,y)$是桥的充要条件是$dfn[x]&lt;low[y]$(假设$y \in subtree(x)$) 让我们想想为什么 $low[y]$表示不经搜索树上的边$y$所能到达的所有节点中其时间戳的最小值,若$dfn[x]&lt;low[y]$,根据定义和性质一,说明只有这条在s搜索树上的边$(x,y)$ ，$y$才能到达$x$,故边$(x,y)$是桥(割边) 割点判定法则 非根点$x$是割点的充要条件是存在一点$y (y \in subtree(x))$,满足$dfn[x]&lt;=low[y]$,类比于上一法则,这里不再赘述 当$x$为根节点时至少要有两个点满足上述条件 大家可以通过图片理解上述过程,粗边都是搜索树上的边 注意 更新$low[x]$ 根据定义,我们只能用$x$在搜索树上儿子的$low[]$值或是一条非搜索树边$(x,y)$中的$dfn[y]$来更新$low[x]$ 重边 在求桥时,若节点$x$与其父亲间有重边,则其中只有一条算搜索树上的边,其他都是非搜索树上的边,可以用来更新. 然而求割点时,由于是点与点联通关系不必考虑重边 代码 桥 1234567891011121314151617181920int dfn[maxn],low[maxn],cnt=0;bool bridge[maxm];void tarjan(int u,int in_edge)&#123;//in_edge--边的编号int v;dfn[u]=low[u]=++cnt;for(ri i=h[u];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[u]=min(low[u],low[v]); if(low[v]&gt;dfn[u])&#123; bridge[i]=bridge[i^1]=1; &#125; &#125; else if(i!=(in_edge^1))&#123; //in_edge^1表示反向边,不是反向边说明是非搜索树边 low[u]=min(low[u],dfn[v]);//通过非树边更新 &#125;&#125;return ;&#125; 割点 123456789101112131415161718192021int dfn[maxn],low[maxn],root,tot=0;bool ans[maxn];void tarjan(int now)&#123;int v,flag=0;dfn[now]=low[now]=++tot;for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[now]=min(low[now],low[v]); if(dfn[now]&lt;=low[v])&#123; flag++; if(now!=root||flag&gt;1)//根节点要有两个满足条件 &#123; if(!ans[now])ans[now]=1;//是割点 &#125; &#125; &#125; else low[now]=min(low[now],dfn[v]);&#125;return ;&#125; 例题 桥+缩点 https://www.luogu.org/problemnew/show/P2860 题解: https://rye-catcher.github.io/2018/07/09/luogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5/ [模板]割点 https://www.luogu.org/problemnew/show/P3388 割点+简单计数 https://www.luogu.org/problemnew/show/P3469 题解:咕咕咕]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu题解P2860[USACO冗杂路径]缩点+桥]]></title>
    <url>%2F2018%2F07%2F09%2Fluogu%E9%A2%98%E8%A7%A3P2860-USACO%E5%86%97%E6%9D%82%E8%B7%AF%E5%BE%84-%E7%BC%A9%E7%82%B9-%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[题目链接https://www.luogu.org/problemnew/show/P2860 https://www.lydsy.com/JudgeOnline/problem.php?id=1718 分析首先这题目的意思就是让任意两点之间至少有两条没有重复道路的路径，很显然，如果这个图不存在桥，就一定满足上述条件。 于是我们就是要求使这个图不存在桥需要连接的最小边数 如果把桥从图中去掉，很显然剩余的联通块中任意两点之间至少有两条没有重复道路的路径（当然也可能不是联通块而是孤立的点），对答案不会产生贡献，我们不妨就将这些联通块缩点，于是就原来的图就变成了一颗树。 然后思考题目要求，当每个节点的度为$2$时任意两点之间至少有两条没有重复道路的路径，因为此时任意节点都有两条不同道路可走，于是用贪心的思想我们让度数为$1$的先互相连接，所以计算出树中的叶节点个数$x$，$ \lceil \frac{x}{2} \rceil $就是答案 注意好象没什么注意的，不过我太菜把$edge [j] .to$写成$edge [i] .to$查了好久的错 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#define ll long long #define ri register int using namespace std;const int maxn=5005;const int maxm=10005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxm&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int n,m;int dfn[maxn],low[maxn],tot=0;bool bridge[maxm];void tarjan(int now,int in_edge)&#123;//所在边的标号 int v;dfn[now]=low[now]=++tot; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!dfn[v])&#123; tarjan(v,i); low[now]=min(low[now],low[v]); if(dfn[now]&lt;low[v])&#123; bridge[i]=bridge[i^1]=true;//是桥 bb++; &#125; &#125; else if(i!=(in_edge^1))&#123;//如果不是在同一条无向边的对应边 low[now]=min(low[now],dfn[v]); &#125; &#125; return ;&#125;int num=0;//联通块的数量int in_block[maxn];//各点所在联通块的标号bool g[maxn][maxn];//重构后的图（储存）void Contraction_Point(int now)&#123;//缩点 int v;in_block[now]=num; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(!bridge[i]&amp;&amp;!in_block[v])&#123; Contraction_Point(v); &#125; &#125; return ;&#125;int du[maxn];inline void solve()&#123; int ans=0,x,y; memset(g,0,sizeof(g)); for(ri i=1;i&lt;=n;i++)&#123; x=in_block[i]; for(ri j=h[i];j;j=edge[j].ne)&#123; y=in_block[edge[j].to]; //太坑了 g[x][y]=g[y][x]=1; &#125; &#125; memset(du,0,sizeof(du)); for(ri i=1;i&lt;=num;i++)&#123; for(ri j=1;j&lt;=num;j++)&#123; if(i!=j&amp;&amp;g[i][j])&#123;du[j]++; &#125; &#125; &#125; for(ri i=1;i&lt;=num;i++)&#123; if(du[i]==1)ans++; &#125; printf("%d",(int)ceil(ans/double(2))); return ;&#125;int main()&#123; int x,y; read(n),read(m); num_edge=1; for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; memset(bridge,0,sizeof(bridge)); tarjan(1,0); memset(in_block,0,sizeof(in_block)); for(ri i=1;i&lt;=n;i++)&#123; if(!in_block[i])&#123; num++; Contraction_Point(i); &#125; &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>桥(割边)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树上差分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 在做一些树上路径修改&amp;查询相关题目时，有时我们用不着树链剖分，类比于序列上的差分，我们可以进行树上差分，不过情况稍有些不同，分为点值上的差分和边权上的差分两种 点值差分 对树上路径$path(x,y)$进行点值差分方法： $tag[x]++,tag[y]++,tag[lca(x,y)]-=2$ 询问$x$被多少个标记覆盖时进行$dfs$,将$x$所有子树节点$tag[]$之和加上$tag[x]$即使被覆盖数目 例题：https://www.luogu.org/problemnew/show/P3128 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=50005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;int n,k;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0;inline void add_edge(int f,int to)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=to; h[f]=num_edge; return ;&#125;int cnt=0;int dep[maxn],fa[maxn],son[maxn],top[maxn],dfn[maxn],rnk[maxn],size[maxn];int sum[maxn];int L,R,dta;void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dep[v]=dep[now]+1,fa[v]=now; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125; void dfs_2(int now,int t)&#123; int v; top[now]=t,dfn[now]=++cnt,rnk[cnt]=now; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125; return ;&#125;void update_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]--,sum[fa[x]]--; return ;&#125;int ans=-inf;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; ans=max(ans,sum[now]); return ;&#125;int main()&#123; int x,y,z; //double st=clock(); read(n),read(k); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; dep[1]=1,fa[1]=0; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=k;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_lca(x,y); &#125; //double ed=clock(); dfs_3(1); printf("%d\n",ans); //printf("%lf\n",ed-st); return 0;&#125; 边权差分 对树上路径$(x,y)$进行差分方法：（注意$x,y$这里还是节点） $tag[x]++,tag[y]++,tag[lca(x,y)]—,tag[fa[lca(x,y)]]—$ 询问$x$被多少标记覆盖方法同上,然而注意！！ 解决相关问题时不能把$tag[root]$算进贡献，因为它没有后继的边 例题：http://poj.org/problem?id=3417 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#define ll long long #define ri register int using namespace std;const int maxn=100005;const int inf=0x7fffffff;template &lt;class T&gt;inline void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125;struct Edge&#123; int ne,to;&#125;edge[maxn&lt;&lt;1];int h[maxn],num_edge=0,n,m;inline void add_edge(int f,int t)&#123; edge[++num_edge].ne=h[f]; edge[num_edge].to=t; h[f]=num_edge; return ;&#125;int dep[maxn],fa[maxn],size[maxn],dfn[maxn],sum[maxn],son[maxn],top[maxn];void dfs_1(int now)&#123; int v; size[now]=1; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; fa[v]=now,dep[v]=dep[now]+1; dfs_1(v); size[now]+=size[v]; if(!son[now]||size[son[now]]&lt;size[v])son[now]=v; &#125; return ;&#125;void dfs_2(int now,int t)&#123; int v; top[now]=t; if(!son[now])return ; dfs_2(son[now],t); for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now]||v==son[now])continue; dfs_2(v,v); &#125;&#125;int ans;void dfs_3(int now)&#123; int v; for(ri i=h[now];i;i=edge[i].ne)&#123; v=edge[i].to; if(v==fa[now])continue; dfs_3(v); sum[now]+=sum[v]; &#125; //cout&lt;&lt;sum[now]&lt;&lt;endl; if(now!=1&amp;&amp;sum[now]==0)ans+=m; else if(now!=1&amp;&amp;sum[now]==1)ans++; return ;&#125;void update_path(int x,int y)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); sum[x]-=2; return;&#125;int main()&#123; int x,y,z; read(n),read(m); for(ri i=1;i&lt;n;i++)&#123; read(x),read(y); add_edge(x,y); add_edge(y,x); &#125; fa[1]=0,dep[1]=1; dfs_1(1); dfs_2(1,1); for(ri i=1;i&lt;=m;i++)&#123; read(x),read(y); sum[x]++,sum[y]++; update_path(x,y); &#125; dfs_3(1); printf("%d\n",ans); return 0;&#125; 例题待填坑 货车运输 天天爱跑步]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记--树链剖分]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言 树链剖分是一个很好用的处理树上统计信息的方法,大致思想就是把树上路径分成$log N$条链,再用线段树之类的数据结构维护一下,所以时间复杂度得到了保障 怎么做 个人认为这篇讲的很好: https://www.cnblogs.com/George1994/p/7821357.html 注意 debug树链剖分对于我来说真是个痛苦的过程,初学时一个错误查了近一个小时才查出来. 首先你要知道线段树上序列是什么? 他们是$dfs_2$中的每个树节点的$dfs$顺序存在$dfn[]$中,$rnk[]$则记录对应$dfn[]$对应的节点编号,这点千万不要搞错，尤其在单点操作时极其容易忽略 build函数 123456789101112 void build(int now,int l,int r)&#123;if(l==r)&#123; mx[now]=sum[now]=w[rnk[l]];//注意是rnk[l] return ;&#125;int mid=(l+r)&gt;&gt;1;build(now&lt;&lt;1,l,mid);build(now&lt;&lt;1|1,mid+1,r);sum[now]=sum[now&lt;&lt;1]+sum[now&lt;&lt;1|1]; mx[now]=max(mx[now&lt;&lt;1],mx[now&lt;&lt;1|1]);return ; &#125; 必要的操作(一定要检查是否写了) 1234 dep[1]=1,fa[1]=0;//假设root是1dfs_1(1);dfs_2(1,1);build(1,1,n); 例题例题1： https://www.luogu.org/problemnew/show/P2590 代码:请戳这里 简要题解: 无 例题2: https://www.luogu.org/problemnew/show/P3384 代码: 请戳这里 简要题解: 无 例题3: https://www.luogu.org/problemnew/show/P3950 代码及题解: https://www.cnblogs.com/Rye-Catcher/p/9351619.html 例题4: https://www.luogu.org/problemnew/show/P4092#sub 这道题比较有意思，题解中找目标所在重链然后倍增的思路在今年NOI中可以运用 代码及题解: https://www.cnblogs.com/Rye-Catcher/p/9275770.html 例题5: 查了好久的错… https://www.luogu.org/problemnew/show/P2146 代码: 请戳这里 简要题解:区间覆盖]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtcoderSoundHound Inc.Contest解题报告]]></title>
    <url>%2F2018%2F07%2F07%2FAtcoderSoundHound-Inc-Contest%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[A C++ Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a+b==15)puts("+"); else if(a*b==15)puts("*"); else puts("x"); return 0;&#125; B C++ Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int maxn=100000;char str[maxn];int main()&#123; int w; scanf("%s",str); scanf("%d",&amp;w); if(w==1)&#123;printf("%s",str);return 0;&#125; for(int i=0;i&lt;strlen(str);i++)&#123; if(i%w==0)&#123; putchar(str[i]); &#125; &#125; return 0;&#125; C 这题画风突变啊喂 这题我比较SB打表没找出规律还是yjw学长点醒了我 $yjw$学长 $orz$ 这题其实是个概率题,长度为$m$,则最多有$m-1$对数字，显然每一对之间是互相不影响的,于是我们先来研究一对数字的情况： 首先每个数字都有n个数字与之配对，总计$n × n$种情况,再考虑对答案做贡献的，假设那一对数字是$x,y (y&gt;x)$,则能做贡献的情况有$n-d$种.当然我们这只是$x&lt;y$的情况，所以共$2×(n-d)$种。当然$d==0$时,就无关大小，只有$(n-d)$种，这需要特判. 然后交上去还是$WA$了,发现强制类型转换写在括号外导致会爆$int$,比较坑 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ri register int using namespace std;template &lt;class T&gt;void read(T &amp;x)&#123; x=0;int ne=0;char c; while(!isdigit(c=getchar()))ne=c=='-'; x=c-48; while(isdigit(c=getchar()))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48; x=ne?-x:x; return ;&#125; int n,m,d;int main()&#123; read(n),read(m),read(d); if(d==0)printf("%.10Lf\n",(long double)(m-1)/n); else if(n&lt;=d)printf("0.0000000\n"); else printf("%.10Lf\n",(long double)(1.00*2*(n-d)*(m-1))/n/n); return 0;&#125; D 这题解法很有意思，比较考验智商 求两个最短路，一个是$s$到$x (x \in [1,n])$的用$yen$衡量的最短路$dis_1(s,x)$,一个是从$t$到$x (x \in [1,n])$的最短路$dis_2(t,x)$,用$snuuk$衡量的最短路 然后我们想，最后$n-1$年出发的时候只用$n$这个点可以交换货币，所以$val[n-1]=dis_1(s,n)+dis_2(t,n)$ 再向下想,在$n-2$年出发时,要么继续到$n$这个点交换货币，要么到$n-1$这个点交换货币，以此类推得到 $val[p]=min(val[p+1],dis_1(s,p)+dis_2(t,p)) p \in [0,n-1]$ 最后初始钱数$-val$值就是对应答案 E 我太菜不知道怎么做，等待咕咕咕的题解吧]]></content>
      <tags>
        <tag>比赛解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误笔记]]></title>
    <url>%2F2018%2F07%2F07%2F%E9%94%99%E8%AF%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[inf值要设大但不要溢出 vis之类的数组使用前都memset一下 memset一些除0外的奇怪的数字时，最好老老实实写for循环（谁叫我脸黑） edge数组不要设小了 C++ 11 不要用register int 手写堆中$heap[]$最好不用结构体，若用，手写swap函数 $bool$ $flag$一定要赋初值！！！！ 树链剖分注意https://www.cnblogs.com/Rye-Catcher/p/9265860.html 边权树上差分注意根节点不能算作贡献]]></content>
      <tags>
        <tag>错误笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APIO2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FAPIO2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0 上了下测试系统，发现居然是毛子的题（貌似系统也是，只给了英文和俄语两个选项），话说T1 A+B什么鬼。 然后向教父请假，教父一脸严肃好吓人，但是我能逃掉期中考hhhhhhhhh 在火车站等车居然看到两个师大的？ Day 1 早上五点多就被吵醒了，到了西客站后等了好久，然后又在宾馆等了好久，然后又背着大包走了好久，然后终于等到了房卡进了房间，话说房间真心不错（然而花的钱也很多） 下午模拟赛在Linux上，然而我$^{tm}$还不会用，VAN蛋，赶紧学了下命令行，自己琢磨GUIDE的字体大小弄了好久。 中午居然组队去吃饭？饭菜好评，按槽位自助打饭好评。接着回宾馆睡了一觉，下午发现可能要迟到了，一路跑过去，然后被一位武汉小哥告知根本没有模拟赛，只是上机？$qwq $ 虚拟机差评，键盘差评，时不时卡顿差评 然后到了实验楼的机房，自装NOI Linux好评，键盘好评，机子速度好评，然而位子这么挤不怕被偷屏吗… 将近五点，在中午食堂等开饭，等了好久被告知在另一个食堂？qwq Day 2 一大早被jyh拉起来到学校旁买本子，结果半天愣是没看到文具店？ 吃完早饭到正志厅准备听课。居然是wuhongxu?!然后一上来先水UOJ群，接着balabala讲起了折纸？！没错，就是折纸，计算机科学中的折纸。PPT全英文差评，看得好费劲，然后基本听不懂orz 然后折纸讲完了，whx比较兴奋地说：“现在我们讲图论中一些有趣的算法”。然而。。。基本听不懂orz,看到APSP(All Pair Shortest Path)各种神仙算法复杂度，和其中一个证明过程，这…orz 接着是秦岳讲课，泊松图像编辑和游戏中的AI，感觉挺有趣的，讲了一堆博弈算法orz 下午终于比较正经，wuvin讲二分，弹幕好评，不过一下就来了什么暴力%之类奇奇怪怪的东西…终于有能听懂的东西了，感动 然后是Kiana(这名字好熟悉啊，好像是哪年的noip还是noi题面中出现过)讲图的匹配…终于有能听懂的东西了，感动……然后讲到了三分图，我：？？？ 后面吃饭领密码条，好象和之前的一模一样 今天也算开拓了视野，JXOI2018 T1 的Gobo sort不是空穴来风，原来真有个叫Bogo sort(猴子排序)的玩意，顺便知晓了后天是PKU的大佬讲课，还知道了那个背着NOI 34th书包的居然是BJ A类队长,而且才初三orz感觉明天要爆0滚粗了… Day 3 上午考试一开始去错了考场真尴尬，居然是在办公楼？！居然还是虚拟机？！然后CCF的工作人员告诉我们只准钦定Linux，用Windows属于作弊（万一不小心按了win键呢） 然后在线看题，还是一样毛子的评测系统，中文翻译好评。T1目测毒瘤数据结构，可以暴力，“小明”是什么鬼？！T2 emmm又是圆，可以暴力 T3 目测图论，可以暴力。 然后我真的只交了暴力，T1，T2第一个Substask，T3第一个$n&lt;=10$的Substask 爆搜 TLE？！最后只得交一个n&lt;=1000 无环的判定，自己想出了一个比较玄学的方法，不知道能不能行。 正当我为我的机智沾沾自喜时，jyh说：不就一个DP.我：…woc好象真的是orz 然后是讲题，T1线段树分治?!什么东西？！T2K-D树？！什么东西？！T3圆方树？！什么东西。 猫锟：“87分的都是暴力没打好” “我翻译的时候就觉得题目太水了，不都是套路嘛” 我：orz 铁牌钦定 Day 4 上午以为8：30吃早饭，结果进入正志厅时老师已经讲课了。话说今天讲课的老师没听过，来的人也更少，是不是一些dalao都去THUPC了…话说我们学校连人都凑不齐… 上午讲数论函数相关，欧拉函数emmm欸我会….杜教筛….有道理 洲阁筛….wtf!? Min_25筛….wtf!? 然后就坐车去八十中，真远啊。 下午听后缀自动机…一下午属于离线状态……顺便打了一下平均边权最大的代码。蒟蒻的我字符串只会Hash(蛤xi) 然后是吃饭，我以为所有窗口饭菜都是一个样…然后就点到最烂的菜…根本没胃口 晚上等到了闭幕式，强行用笔记本为手机续命，一开始先是解释CTSC代码丢失的处理结果，不过对我这种辣鸡没能参加CTSC的选手没影响 然后开始讲APIO，原来这就是APIO的正式考试啊（话说我是不是唯一一个现在才知道的），难怪我这个蒟蒻觉得这么难 “感谢主办方提供实时评测，即时反馈”。。。全场响起了经久不绝的掌声 然后颁奖，中间还有段舞蹈。无疑打铁走人，师大一个高一的拿了Ag，太强了orz 总之第一次参加这样的活动，也学到不少东西，发现自己许多不足：模拟赛基本没打过，临考经验不足，该拿的部分分没拿到，还是要多多努力。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXOI2018游记]]></title>
    <url>%2F2018%2F07%2F07%2FJXOI2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[—Update5.2 成绩出了，见后文 听说省选VAN写游记是传统，本蒟蒻也来发一篇吧。 DAY 0 本来以为省选不在JKFZ举行的结果又是在JKFZ，本校作战感觉终究会是好一些吧，和jyh一起向教父申请停了一天的课，没想到教父居然笑眯眯地答应了，有点出乎意料。 上午和jyh一起打了yjw学长Yali集训时的模拟赛，T1线段树，T2。。。 T3。。。然后愉快地打了线段树，结果。。。爆0。 中午吃完后dalao jyh讲了他T3思路，总之感觉很厉害。 下午dalao jyh写出T3果然是满分，orz。然后被教练拉去和yjw谈一谈赛前经验，然后莫名其妙就变成模拟赛题解讲解，原来T1爆0原因是因为&amp;和|运算不能简单地只是打个标记，我还是naive了。 晚上终于回家了，随便打了下模板，本来想开CSGO，结果偷偷玩了几把混乱大枪战后就睡了。 DAY 1 早上坐车来到JKFZ，打了几遍数论相关模板，连莫比乌斯这种不太会考的都打了一遍。 然而。。。 和jyh一起取考场的时候总是有些奇怪，但还算释然。上机试了下机子，除了键盘有些不适应之外还好没什么问题（一想到NOIP时机子打不开T盘就觉得好笑）。不久题目发了下来。 第一眼看到题面，九条可怜？woc又是吉如一出题。把全部PDF浏览后开始做T1，T1一开始看不懂在草稿纸上推了一遍后却觉得思路还挺容易。 T1大致题面：他先告诉你一个叫gobo sort的排序方法：对于一个成为n的序列a，随机生成另一个长为n序列p，然后构造一个长为n的序列b,使得$b_i$ $=$ $a_{p_i}$。假如这个b是有序的，则停止操作，排序完成，反之不断重复生成p序列的操作. 然后给你一个长为n的序列，和m,l,r。要求你在n长的序列后接上m个值域为[l,r]的数，使得gobo sort中随机生成序列的期望次数最多。 草稿纸上搞了一下发现你只要让每个数字出现的次数平均就好了。具体怎么算这里不再赘述，然而在考场上我发现有几个地方需要注意： 离散化 2.可以用堆维护 3.由于有阶乘，除和取模操作，需要逆元. 然而蛋疼的是我忘了逆元怎么打！！！在考场上手推好久，只得作罢，去做T2 T3 T2打了暴力，T3连暴力都不知道怎么打… 总之出了考场后很颓废，T1没打逆元，什么优化也没加，估计凉凉。 然后下午yjw学长搞来份solution，看了一下T1思路确时没错,T2用sigma推了一大堆结果时间复杂度只有O（r）?T3区间DP，好难根本想不到。 后面看了下逆元，发现原来这么容易求,考场上用费马小定理却没推出来…还是我太弱了。 DAY 懒得数了 五一节后成绩出来了，居然有50分，我想应该是T1 30+T2 20+T3 0瞄了一眼大多都是这个分段，然而我的NOIP只有120，前面都是200+或300+，我还是太蒻了,学长进了A类，不过有一个赣州中学高一省队爷，真的强…以及一位爆0 A队女选手。 然后在知乎上看到这个： 厚颜无耻的出题人 %%% 后记 总之还是意料之中吧，也恰恰反映我的不足，以后还是要多刷题，坚持在NOIP前一月把算法竞赛进阶指南刷完，（现在看怕是没机会了）争取考400+(这么弱怎么可能)。 总之应用一句在其他dalao滚粗记中的话吧： _一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程 。 ——长者_]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F07%2F07%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[Hello World 第一篇博客纪念 $ \mathcal{Enjoy Reading Here} $]]></content>
      <tags>
        <tag>Not Yet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
