<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>省选前模板复习 | Rye_Catcher</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">省选前模板复习</h1><a id="logo" href="/.">Rye_Catcher</a><p class="description">Stay Young,Stay Simple</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comment"> 留言</i></a><a href="/Friend-Links/"><i class="fa fa-friend"> 友链</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">省选前模板复习</h1><div class="post-meta"><a href="/2019/05/10/省选前模板复习/#comments" class="comment-count"></a><p><span class="date">May 10, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h2><p>也许是OI生涯最后一场正式比赛了，说是省选前模板，其实都是非常基础的东西，穿插了英文介绍和部分代码实现</p>
<p>祝各位参加JXOI2019的都加油吧</p>
<p>也希望今年JX能翻身,在国赛中夺金</p>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><p>见<a href="https://rye-catcher.github.io/2019/05/09/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93-1/">数学知识小结</a></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP算法Knuth-Morris-Pratt-Algorithm"><a href="#KMP算法Knuth-Morris-Pratt-Algorithm" class="headerlink" title="KMP算法Knuth-Morris-Pratt Algorithm"></a>KMP算法Knuth-Morris-Pratt Algorithm</h3><p>KMP算法,又称模式匹配算法,是用来在一个文本串(text string)<code>s</code>中找到所有模式串(pattern)<code>w</code>出现的位置.</p>
<p>它是通过当失配(mismatch)发生时,模式串本身能提供足够的信息来决定下一个匹配能从哪里开始,这样就可以避开对前面已经匹配好的字符的再次遍历检查(即暴力做法)</p>
<p>“In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, the <strong>Knuth–Morris–Pratt string-searching algorithm</strong> (or <strong>KMP algorithm</strong>) searches for occurrences of a “word” <code>W</code> within a main “text string” <code>S</code> by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.”</p>
<p>来源: <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">维基百科</a></p>
<p>我们需要构造一个函数<code>next</code>,<code>next[n]</code>表示的是模式串<code>w</code>中以第n个字符结尾的非前缀子串(substring)与<code>w</code>的前缀(prefix)能够匹配的最大长度</p>
<p>具体实现过程与思路见<a href="https://oi-wiki.org/string/prefix-function/" target="_blank" rel="noopener">OI WIKI</a></p>
<p>简单说一下比较难懂的在<code>w[i]!=w[j+1]</code>,为什么指针<code>j</code>跳向<code>next[j]</code></p>
<p>显然<code>w[1~j]</code>是等于<code>i-1</code>前<code>j</code>个字母的字串的,但是我们比较发现<code>w[j+1]!=w[i]</code></p>
<p>我们想要的新的<code>j</code>是使得除了第$j+1$个字符需要与<code>w[i]</code>比较外,<code>w[1]~w[j]</code>的前缀等于<code>i-1</code>(包括<code>i-1</code>)前<code>j</code>个字母的后缀(suffix)</p>
<p>又由于<code>i-1</code>前任意<code>k(k&lt;=next[j])</code>个字符后缀等于<code>next[j]</code>前任意<code>k</code>个字母的后缀</p>
<p>又因为<code>w[1~next[next[j]]]</code>等于<code>next[j]</code>前<code>next[next[j]]</code>长度的后缀,即等于<code>i-1</code>前<code>next[next[j]]</code>长度的后缀</p>
<p>所以新的<code>j=next[j]</code>就满足上述条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);<span class="comment">//a is the text string</span></span><br><span class="line">ne[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//next</span></span><br><span class="line"><span class="keyword">for</span>(ri i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">     <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b[i]!=b[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">     <span class="keyword">if</span>(b[i]==b[j+<span class="number">1</span>])j++;</span><br><span class="line">     ne[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ri i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">     <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=b[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">     <span class="keyword">if</span>(a[i]==b[j+<span class="number">1</span>])j++;</span><br><span class="line">     fail[i]=j;</span><br><span class="line">     <span class="keyword">if</span>(fail[i]==m)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-m+<span class="number">1</span>);</span><br><span class="line">     fail[i]=<span class="number">1</span>;</span><br><span class="line">     j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希Hash-Function"><a href="#哈希Hash-Function" class="headerlink" title="哈希Hash Function"></a>哈希Hash Function</h3><p>不想中文介绍了QAQ,OI中常用于数据的<strong>离散化(Discretization)</strong></p>
<p>关于更多<a href="https://rye-catcher.github.io/2018/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F/">离散化内容</a></p>
<p>但是哈希函数有可能发生<strong>哈希冲突(Hash Collision)</strong>,为了避免这种情况,我们可以采取双哈希或是拉链</p>
<p>“A <strong>hash function</strong> is any <a href="https://en.wikipedia.org/wiki/Function_(mathematics" target="_blank" rel="noopener">function</a>) that can be used to map <a href="https://en.wikipedia.org/wiki/Data_(computing" target="_blank" rel="noopener">data</a>) of arbitrary size onto data of a fixed size. The values returned by a hash function are called <strong>hash values</strong>, <strong>hash codes</strong>, <strong>digests</strong>, or simply <strong>hashes</strong>. Hash functions are often used in combination with a <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">hash table</a>, a common <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener">data structure</a> used in computer software for rapid data lookup. Hash functions accelerate table or database lookup by detecting duplicated records in a large file. One such application is finding similar stretches in DNA sequences. They are also useful in <a href="https://en.wikipedia.org/wiki/Cryptography" target="_blank" rel="noopener">cryptography</a>.”</p>
<p>来源:<a href="https://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">维基百科</a></p>
<p>字符串哈希我一般用<a href="https://www.cnblogs.com/Rye-Catcher/p/8723665.html" target="_blank" rel="noopener">Rabin-Karp Hash</a>,更多相关内容在链接里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line">ull x,hash_table[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_hash</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ri i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">        x=x*<span class="number">131</span>+a[i]<span class="number">-31</span>;</span><br><span class="line">        hash_table[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于两个串,我们可以将它们按上述方法<strong>映射(mapping)</strong>到哈希表后通过二分(binary serach)或是倍增(QAQ这个英语怎么说啊)来快速匹配</p>
<p>主要根据这个可以$O(1)$地判断两个字串是否相等</p>
<p>   $w_{str_{i,j}}$ </p>
<p>   $=($ $a_i$ $p^{j-i}$+$a_{i+1}$ $p^{j-i-1}$+…+$a_{j}$ $p^0$)</p>
<p>   $=$ $w_{pre_{j}}$ $-$ $w_{pre_{i-1}}$ $p^{j-i+1}$</p>
<h2 id="数据结构Data-Structure"><a href="#数据结构Data-Structure" class="headerlink" title="数据结构Data Structure"></a>数据结构Data Structure</h2><h3 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h3><p>栈是只有一端能进出元素的线性数据结构,所以它是<strong>后进后出(LIFO,Last In First Out)</strong>的</p>
<p>有<strong>入栈(push)</strong>与<strong>出栈(pop)</strong>两种基本操作</p>
<p>“In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, a <em>stack</em> is an <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener">abstract data type</a> that serves as a <a href="https://en.wikipedia.org/wiki/Collection_(computing" target="_blank" rel="noopener">collection</a>) of elements, with two principal operations:</p>
<ul>
<li><strong>push</strong>, which adds an element to the collection, and</li>
<li><strong>pop</strong>, which removes the most recently added element that was not yet removed.</li>
</ul>
<p>The order in which elements come off a stack gives rise to its alternative name, <strong>LIFO</strong> (<strong>last in, first out</strong>). Additionally, a <a href="https://en.wikipedia.org/wiki/Peek_(data_type_operation" target="_blank" rel="noopener">peek</a>) operation may give access to the top without modifying the stack.<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">[1]</a>#cite_note-1)The name “stack” for this type of structure comes from the analogy to a set of physical items stacked on top of each other, which makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">[2]</a>#cite_note-clrs-2)”</p>
<p>来源:<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">维基百科</a>)</p>
<h3 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h3><p>队列是一种”先进先出(FIFO,First In Fitst Out)”的线性数据结构.一般元素从右端入队,从左端出队.为了节省空间实现上可以采用循环队列</p>
<h3 id="链表Linked-List"><a href="#链表Linked-List" class="headerlink" title="链表Linked List"></a>链表Linked List</h3><p>(这几个都感觉没什么好说的)</p>
<p>讲一下<strong>邻接表(Adjacency List)</strong>吧,它可以看成是”带有索引数组的多个数据链表”,这种所引就是链表的表头,表头又构成了一个表头(headers)数组</p>
<p>存图常用邻接表或是邻接矩阵(Adjacency Matrix)</p>
<p>邻接表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num_edge=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to,dis;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">    edge[++num_edge].ne=h[f];</span><br><span class="line">    edge[num_edge].to=to;</span><br><span class="line">    edge[num_edge].dis=dis;</span><br><span class="line">    h[f]=num_edge;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a>字典树Trie</h3><p>字典树是一种用于实现字符串快速检索的多叉树结构，其节点都拥有字符指针.</p>
<p>“Trie is an efficient information <strong>reTrieval</strong> data structure.Using trie,search complexities can be brought too optimal limit(O(M),M is key length).However the penalty is on Trie storage requirements.”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[maxn][<span class="number">27</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> end[maxn][<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=tot,x;</span><br><span class="line">    <span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        x=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[t][x]==<span class="number">0</span>)trie[t][x]=++tot;</span><br><span class="line">        t=trie[t][x];</span><br><span class="line">    &#125;</span><br><span class="line">    end[t][x]=<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Match_Ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=tot,x;</span><br><span class="line">    <span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        x=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        t=trie[t][x];</span><br><span class="line">        <span class="keyword">if</span>(!t)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end[t][x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉堆Binary-Heap"><a href="#二叉堆Binary-Heap" class="headerlink" title="二叉堆Binary Heap"></a>二叉堆Binary Heap</h3><p>二叉堆是一颗满足堆性质的完全二叉树.根据排序方式可以分为<strong>大根堆(Max-Heap)</strong>和<strong>小根堆(Min-Heap)</strong></p>
<p>对于大根堆,任意一个非根节点的权值都小于等于其父节点的权值;小根堆则反之</p>
<p>“A binary heap is a complete binary tree which satisfies the heap ordering property.The ordering can be one of two types:the min-heap property and the max-heap property.The value of each node of the max-heap is less than or equal to the value of its parent,with the maximum-value element at the root”</p>
<p>来源:<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html" target="_blank" rel="noopener">cs.cmu.edu</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn],n;<span class="comment">//max-heap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_modify</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[p]&gt;heap[p&gt;&gt;<span class="number">1</span>])&#123;</span><br><span class="line">            swap(heap[p],heap[p&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">            p=p&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    heap[++n]=val;</span><br><span class="line">    up(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=p&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;n&amp;&amp;heap[s]&lt;heap[s+<span class="number">1</span>])s++;<span class="comment">//choost the maximum one of the two sons</span></span><br><span class="line">        <span class="keyword">if</span>(heap[s]&gt;heap[p])&#123;</span><br><span class="line">            swap(heap[s],heap[p]);</span><br><span class="line">            p=s,s=s&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">    down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树Segment-Tree"><a href="#线段树Segment-Tree" class="headerlink" title="线段树Segment Tree"></a>线段树Segment Tree</h3><p>咕</p>
<h2 id="图论Graph-Theory"><a href="#图论Graph-Theory" class="headerlink" title="图论Graph Theory"></a>图论Graph Theory</h2><h3 id="Dijkstra算法Dijkstra-Algorithm"><a href="#Dijkstra算法Dijkstra-Algorithm" class="headerlink" title="Dijkstra算法Dijkstra Algorithm"></a>Dijkstra算法Dijkstra Algorithm</h3><p>DIjkstra算法是为了解决<strong>单源最短路径问题(Single Source Shortest Path,SSSP)</strong>的，简单来说，就是求原点到其它所有点(vertex pl.vertices)的最短路(shortest path)</p>
<p>它是基于一个贪心思想,要求所有边都是非负的.大致就是不断拓展一颗最短路生成树</p>
<p>“Dijkstra’s algorithm is very similar to Prim’s algorithm for <strong>minimum spanning tree(MST)</strong>.Like Prim’s MST,we generate a SPT(shortest path tree) with given source as root.We maintain two sets,one set contain vertices included in the shortest path tre,other set includes vertices not yet included in shortest path tree.At every step,we find a vertex which is in the other set and has a mimnum distance from the source.”</p>
<p>来源:<a href="https://www.google.com/amp/s/www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/amp/" target="_blank" rel="noopener">geeksforgeeks.org</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Vertex &amp; a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;a.d;</span><br><span class="line">    &#125;</span><br><span class="line">    Vertex()&#123;;&#125;</span><br><span class="line">    Vertex(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;id=x,d=y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;Vertex&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">    edge[++num_edge].ne=h[f];</span><br><span class="line">    edge[num_edge].to=to;</span><br><span class="line">    edge[num_edge].dis=dis;</span><br><span class="line">    h[f]=num_edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(Vertex(s,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        u=q.top().id,w=q.top().d;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(ri i=h[u];i;i=edge[i].ne)&#123;</span><br><span class="line">            v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.push(Vertex(v,dis[v]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ri i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA"><a href="#Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA" class="headerlink" title="Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA"></a>Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA</h3><p>忽然发现ddl干不完了,因此介绍咕了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line">    dis[s]=<span class="number">0</span>,vis[s]=<span class="number">1</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        u=q.top();q.pop();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=edge[i].ne)&#123;</span><br><span class="line">            v=edge[i].to,w=edge[i].dis;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!dis[v])&#123;q.push(v);dis[v]=<span class="number">1</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd算法Floyd-Warshall-Algorithm"><a href="#Floyd算法Floyd-Warshall-Algorithm" class="headerlink" title="Floyd算法Floyd Warshall Algorithm"></a>Floyd算法Floyd Warshall Algorithm</h3><p>Floyd算法是基于动态规划思想来解决任意两点之间最短路径(All Pairs Shortest Path problem,APSP)的算法</p>
<p>亦可用于可传递的关系(传递闭包),这个也先挖坑吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    dis[x][y]=min(dis[x][y],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法Kruskal-Algorithm"><a href="#Kruskal算法Kruskal-Algorithm" class="headerlink" title="Kruskal算法Kruskal Algorithm"></a>Kruskal算法Kruskal Algorithm</h3><p>Kruskal算法是求出一张给定联通边带权无向图的最小生成树算法.那么什么是最小生成树?</p>
<p>“Given a connected and undirected graph, a <em>spanning tree</em> of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. A <em>minimum spanning tree (MST)</em> or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.”</p>
<p>来源:<a href="https://www.geeksforgeeks.org/?p=26604" target="_blank" rel="noopener">Geeksforgeeks</a> 强烈安利这个网站,写的浅显易懂而且最重要的是,it is not blocked</p>
<p>Kruskal算法维护无向图的最小生成森林,每次在连接两个森林的边中找一条权值最小的将两个森林连起来.对于连通性我们使用并查集维护</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp; a)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis&lt;a.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)fa[x]=get(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].dis);</span><br><span class="line">	&#125;</span><br><span class="line">    sort(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    	u=edge[i].u,v=edge[i].v;</span><br><span class="line">        u=get(u),v=get(v);</span><br><span class="line">        <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">            fa[u]=v;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树链剖分Tree-Chain-Partition"><a href="#树链剖分Tree-Chain-Partition" class="headerlink" title="树链剖分Tree Chain Partition"></a>树链剖分Tree Chain Partition</h3><p>详细介绍咕了</p>
<p>将树上操作转化为线段树,由于重链数量级是$log N$的,线段树时间复杂度是$log N$,总时间复杂度是$log^2 N$</p>
<p>还可以同时求LCA,但是操作时有许多细节需要注意,尤其是<code>dfn[]</code>和<code>rnk[]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],dfn[maxn],rnk[maxn],w[maxn],dep[maxn],top[maxn],son[maxn],size[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_1</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;size[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[now];i;i=edge[i].to)&#123;</span><br><span class="line">        v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[now])<span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=now,dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">        dfs_1(v);</span><br><span class="line">        size[now]+=size[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[now]||size[v]&gt;size[son[now]])son[now]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    top[now]=t,dfn[now]=++cnt,rnk[cnt]=now;</span><br><span class="line">    <span class="keyword">if</span>(!son[now])<span class="keyword">return</span> ;</span><br><span class="line">    dfs_2(son[now],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[now];i;i=edge[i].ne)&#123;</span><br><span class="line">        v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==son[now]||v==fa[now])<span class="keyword">continue</span>;</span><br><span class="line">        dfs_2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L,R;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation_on_path</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">        L=dfn[top[x]],R=dfn[x];</span><br><span class="line">        operation_on_segmenttree(L,R);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]&gt;dfn[y])swap(x,y);<span class="comment">//x is the LCA</span></span><br><span class="line">    L=dfn[x],R=dfn[y];</span><br><span class="line">    operation_on_segmenttree(L,R);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation_on_subtree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    L=dfn[x],R=dfn[x]+size[x]<span class="number">-1</span>;</span><br><span class="line">    operation_on_segmenttree(L,R);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划Dynamic-Programming"><a href="#动态规划Dynamic-Programming" class="headerlink" title="动态规划Dynamic Programming"></a>动态规划Dynamic Programming</h2><p>估计要咕了</p>
</div><div class="tags"><a href="/tags/模板/">模板</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/05/09/数学知识小结-1/" class="next">数学知识小结#1</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNzg5Ny8xNDQyNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PREFACE"><span class="toc-text">PREFACE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学知识"><span class="toc-text">数学知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP算法Knuth-Morris-Pratt-Algorithm"><span class="toc-text">KMP算法Knuth-Morris-Pratt Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希Hash-Function"><span class="toc-text">哈希Hash Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构Data-Structure"><span class="toc-text">数据结构Data Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈Stack"><span class="toc-text">栈Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列Queue"><span class="toc-text">队列Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表Linked-List"><span class="toc-text">链表Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典树Trie"><span class="toc-text">字典树Trie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉堆Binary-Heap"><span class="toc-text">二叉堆Binary Heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树Segment-Tree"><span class="toc-text">线段树Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论Graph-Theory"><span class="toc-text">图论Graph Theory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra算法Dijkstra-Algorithm"><span class="toc-text">Dijkstra算法Dijkstra Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA"><span class="toc-text">Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd算法Floyd-Warshall-Algorithm"><span class="toc-text">Floyd算法Floyd Warshall Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal算法Kruskal-Algorithm"><span class="toc-text">Kruskal算法Kruskal Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树链剖分Tree-Chain-Partition"><span class="toc-text">树链剖分Tree Chain Partition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划Dynamic-Programming"><span class="toc-text">动态规划Dynamic Programming</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/省选前模板复习/">省选前模板复习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/09/数学知识小结-1/">数学知识小结#1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/匆匆四月/">匆匆四月</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/26/23rdSM2项目JX省游记/">23rdSM2项目JX省游记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/17/AFO/">AFO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/写在NOIP2018前/">写在NOIP2018前</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/07/Atcoder-CodeForces杂题11-7/">Atcoder&CodeForces杂题11.7</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/Atcoder-CodeForces杂题11-6/">Atcoder&CodeForces杂题11.6</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/30/NOIP2018模拟赛10-29-垫底报告/">[NOIP2018模拟赛10.29]垫底报告</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/学习笔记-二分图匹配与匈牙利算法/">[学习笔记]二分图匹配与匈牙利算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/质数筛法/" style="font-size: 15px;">质数筛法</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/AFO/" style="font-size: 15px;">AFO</a> <a href="/tags/题解/" style="font-size: 15px;">题解</a> <a href="/tags/乱搞/" style="font-size: 15px;">乱搞</a> <a href="/tags/思维/" style="font-size: 15px;">思维</a> <a href="/tags/比赛解题报告/" style="font-size: 15px;">比赛解题报告</a> <a href="/tags/线段树/" style="font-size: 15px;">线段树</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/计数/" style="font-size: 15px;">计数</a> <a href="/tags/扩展欧拉定理/" style="font-size: 15px;">扩展欧拉定理</a> <a href="/tags/莫队/" style="font-size: 15px;">莫队</a> <a href="/tags/递推/" style="font-size: 15px;">递推</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/模拟/" style="font-size: 15px;">模拟</a> <a href="/tags/线性DP/" style="font-size: 15px;">线性DP</a> <a href="/tags/贪心/" style="font-size: 15px;">贪心</a> <a href="/tags/枚举/" style="font-size: 15px;">枚举</a> <a href="/tags/二分/" style="font-size: 15px;">二分</a> <a href="/tags/树的直径/" style="font-size: 15px;">树的直径</a> <a href="/tags/计算几何/" style="font-size: 15px;">计算几何</a> <a href="/tags/蛤/" style="font-size: 15px;">蛤</a> <a href="/tags/二次扫描与换根/" style="font-size: 15px;">二次扫描与换根</a> <a href="/tags/树形DP/" style="font-size: 15px;">树形DP</a> <a href="/tags/Not-Yet/" style="font-size: 15px;">Not Yet</a> <a href="/tags/状压DP/" style="font-size: 15px;">状压DP</a> <a href="/tags/Hexo教程/" style="font-size: 15px;">Hexo教程</a> <a href="/tags/扫描线/" style="font-size: 15px;">扫描线</a> <a href="/tags/倍增/" style="font-size: 15px;">倍增</a> <a href="/tags/折半搜索/" style="font-size: 15px;">折半搜索</a> <a href="/tags/状态压缩/" style="font-size: 15px;">状态压缩</a> <a href="/tags/离散化/" style="font-size: 15px;">离散化</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/最短路/" style="font-size: 15px;">最短路</a> <a href="/tags/SM2/" style="font-size: 15px;">SM2</a> <a href="/tags/并查集/" style="font-size: 15px;">并查集</a> <a href="/tags/扩展欧几里得/" style="font-size: 15px;">扩展欧几里得</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/概率与期望/" style="font-size: 15px;">概率与期望</a> <a href="/tags/区间DP/" style="font-size: 15px;">区间DP</a> <a href="/tags/背包DP/" style="font-size: 15px;">背包DP</a> <a href="/tags/组合数学/" style="font-size: 15px;">组合数学</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/剪枝/" style="font-size: 15px;">剪枝</a> <a href="/tags/树链剖分/" style="font-size: 15px;">树链剖分</a> <a href="/tags/数论分块/" style="font-size: 15px;">数论分块</a> <a href="/tags/欧拉函数与简化剩余系/" style="font-size: 15px;">欧拉函数与简化剩余系</a> <a href="/tags/中国剩余定理/" style="font-size: 15px;">中国剩余定理</a> <a href="/tags/C-STL/" style="font-size: 15px;">C++ STL</a> <a href="/tags/最小生成树/" style="font-size: 15px;">最小生成树</a> <a href="/tags/变式/" style="font-size: 15px;">变式</a> <a href="/tags/桥-割边/" style="font-size: 15px;">桥(割边)</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/开源UOJ教程/" style="font-size: 15px;">开源UOJ教程</a> <a href="/tags/瞎搞/" style="font-size: 15px;">瞎搞</a> <a href="/tags/二分图匹配/" style="font-size: 15px;">二分图匹配</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/Tarjan/" style="font-size: 15px;">Tarjan</a> <a href="/tags/差分/" style="font-size: 15px;">差分</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/C-STL/" style="font-size: 15px;">C++STL</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/错误笔记/" style="font-size: 15px;">错误笔记</a> <a href="/tags/强连通分量/" style="font-size: 15px;">强连通分量</a> <a href="/tags/A-IDA/" style="font-size: 15px;">A*/IDA*</a> <a href="/tags/模板/" style="font-size: 15px;">模板</a> <a href="/tags/线段树合并/" style="font-size: 15px;">线段树合并</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.cnblogs.com/Rye-Catcher/" title="旧博客" target="_blank">旧博客</a><ul></ul><a href="https://rye-catcher.github.io/" title="----巨佬同学----" target="_blank">----巨佬同学----</a><ul></ul><a href="https://www.cnblogs.com/xxzh/" title="星星之火 -- in JX" target="_blank">星星之火 -- in JX</a><ul></ul><a href="https://rye-catcher.github.io/" title="--有幸结识的大佬--" target="_blank">--有幸结识的大佬--</a><ul></ul><a href="http://cnblogs.com/huyufeifei/" title="huyufeifei" target="_blank">huyufeifei</a><ul></ul><a href="http://mayflyyh.com" title="额冻豆腐" target="_blank">额冻豆腐</a><ul></ul><a href="http://www.cnblogs.com/ppprseter/" title="威慑▲本人露迭月 -- in HB" target="_blank">威慑▲本人露迭月 -- in HB</a><ul></ul><a href="https://home.cnblogs.com/u/ouuan" title="yyfouuan -- in HB" target="_blank">yyfouuan -- in HB</a><ul></ul><a href="http://www.wjyyy.top/" title="wjyyy -- in HB" target="_blank">wjyyy -- in HB</a><ul></ul><a href="https://oi.logey.cn/" title="Logey -- in SD" target="_blank">Logey -- in SD</a><ul></ul><a href="https://acfunction.github.io/" title="AcFunction -- in BJ" target="_blank">AcFunction -- in BJ</a><ul></ul><a href="http://bubbleioa.top/" title="冒泡ioa -- in JX" target="_blank">冒泡ioa -- in JX</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Rye_Catcher.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>