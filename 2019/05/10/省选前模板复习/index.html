<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo, RyeCatcher, OI">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="Rye_Catcher" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="//fonts.lug.ustc.edu.cn/css?family=Lato|Roboto+Condensed|Skranji|Ubuntu|Ubuntu+Mono">
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          $(e).before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout with line number.
              return trigger.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          $(e).parent().before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout without line number.
              return trigger.nextElementSibling.firstChild;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>省选前模板复习 | Rye_Catcher - Stay Young,Stay Simple</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">Rye_Catcher</a></h1>
        <h2 class="subtitle">Stay Young,Stay Simple</h2>
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
        <li role="menuitem"><a href="/slides/"><i class="fas fa-share"></i><span class="menu-text">slides</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://rye-catcher.github.io/2019/05/10/省选前模板复习/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="Rye_Catcher">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="https://s1.ax1x.com/2018/08/11/PcnGYn.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="Rye_Catcher">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">省选前模板复习</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2019-05-10T11:25:44+08:00">2019-05-10 11:25:44</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SM2/" itemprop="url" rel="index"><span itemprop="name">SM2</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SM2/总结/" itemprop="url" rel="index"><span itemprop="name">总结</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h2 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h2><p>也许是OI生涯最后一场正式比赛了，说是省选前模板，其实都是非常基础的东西，穿插了英文介绍和部分代码实现</p>
<p>祝各位参加JXOI2019的都加油吧</p>
<p>也希望今年JX能翻身,在国赛中夺金</p>
<p>Some Words:</p>
<p>property n. [C] (数学)性质</p>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><p>见<a href="https://rye-catcher.github.io/2019/05/09/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93-1/">数学知识小结</a></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP算法Knuth-Morris-Pratt-Algorithm"><a href="#KMP算法Knuth-Morris-Pratt-Algorithm" class="headerlink" title="KMP算法Knuth-Morris-Pratt Algorithm"></a>KMP算法Knuth-Morris-Pratt Algorithm</h3><p>KMP算法,又称模式匹配算法,是用来在一个文本串(text string)<code>s</code>中找到所有模式串(pattern)<code>w</code>出现的位置.</p>
<p>它是通过当失配(mismatch)发生时,模式串本身能提供足够的信息来决定下一个匹配能从哪里开始,这样就可以避开对前面已经匹配好的字符的再次遍历检查(即暴力做法)</p>
<p>“In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, the <strong>Knuth–Morris–Pratt string-searching algorithm</strong> (or <strong>KMP algorithm</strong>) searches for occurrences of a “word” <code>W</code> within a main “text string” <code>S</code> by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.”</p>
<p>来源: <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">维基百科</a></p>
<p>我们需要构造一个函数<code>next</code>,<code>next[n]</code>表示的是模式串<code>w</code>中以第n个字符结尾的<strong>非前缀子串(substring)</strong>与<code>w</code>的<strong>前缀(prefix)</strong>能够匹配的最大长度</p>
<p>具体实现过程与思路见<a href="https://oi-wiki.org/string/prefix-function/" target="_blank" rel="noopener">OI WIKI</a></p>
<p>简单说一下比较难懂的在<code>w[i]!=w[j+1]</code>,为什么指针<code>j</code>跳向<code>next[j]</code></p>
<p>显然<code>w[1~j]</code>是等于<code>i-1</code>前<code>j</code>个字母的字串的,但是我们比较发现<code>w[j+1]!=w[i]</code></p>
<p>我们想要的新的<code>j</code>是使得除了第$j+1$个字符需要与<code>w[i]</code>比较外,<code>w[1]~w[j]</code>的前缀等于<code>i-1</code>(包括<code>i-1</code>)前<code>j</code>个字母的<strong>后缀(suffix)</strong></p>
<p>又由于<code>i-1</code>前任意<code>k(k&lt;=next[j])</code>个字符后缀等于<code>next[j]</code>前任意<code>k</code>个字母的后缀</p>
<p>又因为<code>w[1~next[next[j]]]</code>等于<code>next[j]</code>前<code>next[next[j]]</code>长度的后缀,即等于<code>i-1</code>前<code>next[next[j]]</code>长度的后缀</p>
<p>所以新的<code>j=next[j]</code>就满足上述条件</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">n=<span class="hljs-built_in">strlen</span>(a+<span class="hljs-number">1</span>);m=<span class="hljs-built_in">strlen</span>(b+<span class="hljs-number">1</span>);<span class="hljs-comment">//a is the text string</span><br>ne[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//next</span><br><span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>     <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;b[i]!=b[j+<span class="hljs-number">1</span>])j=ne[j];<br>     <span class="hljs-keyword">if</span>(b[i]==b[j+<span class="hljs-number">1</span>])j++;<br>     ne[i]=j;<br>&#125;<br><span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>     <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;a[i]!=b[j+<span class="hljs-number">1</span>])j=ne[j];<br>     <span class="hljs-keyword">if</span>(a[i]==b[j+<span class="hljs-number">1</span>])j++;<br>     fail[i]=j;<br>     <span class="hljs-keyword">if</span>(fail[i]==m)&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,i-m+<span class="hljs-number">1</span>);<br>     fail[i]=<span class="hljs-number">1</span>;<br>     j=ne[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="哈希Hash-Function"><a href="#哈希Hash-Function" class="headerlink" title="哈希Hash Function"></a>哈希Hash Function</h3><p>不想中文介绍了QAQ,OI中常用于数据的<strong>离散化(Discretization)</strong></p>
<p>关于更多<a href="https://rye-catcher.github.io/2018/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E7%A7%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E6%96%B9%E5%BC%8F/">离散化内容</a></p>
<p>但是哈希函数有可能发生<strong>哈希冲突(Hash Collision)</strong>,为了避免这种情况,我们可以采取双哈希或是拉链</p>
<p>“A <strong>hash function</strong> is any <a href="https://en.wikipedia.org/wiki/Function_(mathematics" target="_blank" rel="noopener">function</a>) that can be used to map <a href="https://en.wikipedia.org/wiki/Data_(computing" target="_blank" rel="noopener">data</a>) of arbitrary size onto data of a fixed size. The values returned by a hash function are called <strong>hash values</strong>, <strong>hash codes</strong>, <strong>digests</strong>, or simply <strong>hashes</strong>. Hash functions are often used in combination with a <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">hash table</a>, a common <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener">data structure</a> used in computer software for rapid data lookup. Hash functions accelerate table or database lookup by detecting duplicated records in a large file. One such application is finding similar stretches in DNA sequences. They are also useful in <a href="https://en.wikipedia.org/wiki/Cryptography" target="_blank" rel="noopener">cryptography</a>.”</p>
<p>来源:<a href="https://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">维基百科</a></p>
<p>字符串哈希我一般用<a href="https://www.cnblogs.com/Rye-Catcher/p/8723665.html" target="_blank" rel="noopener">Rabin-Karp Hash</a>,更多相关内容在链接里</p>
<figure class="hljs highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ull unsigned long long </span><br>ull x,hash_table[maxn];<br><span class="hljs-keyword">char</span> str[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">0</span>;str[i];i++)&#123;<br>        x=x*<span class="hljs-number">131</span>+a[i]<span class="hljs-number">-31</span>;<br>        hash_table[i]=x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于两个串,我们可以将它们按上述方法<strong>映射(mapping)</strong>到哈希表后通过二分(binary serach)或是倍增(QAQ这个英语怎么说啊)来快速匹配</p>
<p>主要根据这个可以$O(1)$地判断两个字串是否相等</p>
<p>   $w_{str_{i,j}}$ </p>
<p>   $=($ $a_i$ $p^{j-i}$+$a_{i+1}$ $p^{j-i-1}$+…+$a_{j}$ $p^0$)</p>
<p>   $=$ $w_{pre_{j}}$ $-$ $w_{pre_{i-1}}$ $p^{j-i+1}$</p>
<h2 id="数据结构Data-Structure"><a href="#数据结构Data-Structure" class="headerlink" title="数据结构Data Structure"></a>数据结构Data Structure</h2><h3 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h3><p>栈是只有一端能进出元素的线性数据结构,所以它是<strong>后进后出(LIFO,Last In First Out)</strong>的</p>
<p>有<strong>入栈(push)</strong>与<strong>出栈(pop)</strong>两种基本操作</p>
<p>“In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, a <em>stack</em> is an <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener">abstract data type</a> that serves as a <a href="https://en.wikipedia.org/wiki/Collection_(computing" target="_blank" rel="noopener">collection</a>) of elements, with two principal operations:</p>
<ul>
<li><strong>push</strong>, which adds an element to the collection, and</li>
<li><strong>pop</strong>, which removes the most recently added element that was not yet removed.</li>
</ul>
<p>The order in which elements come off a stack gives rise to its alternative name, <strong>LIFO</strong> (<strong>last in, first out</strong>). Additionally, a <a href="https://en.wikipedia.org/wiki/Peek_(data_type_operation" target="_blank" rel="noopener">peek</a>) operation may give access to the top without modifying the stack.<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">[1]</a>#cite_note-1)The name “stack” for this type of structure comes from the analogy to a set of physical items stacked on top of each other, which makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">[2]</a>#cite_note-clrs-2)”</p>
<p>来源:<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type" target="_blank" rel="noopener">维基百科</a>)</p>
<h3 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h3><p>队列是一种”先进先出(FIFO,First In Fitst Out)”的线性数据结构.一般元素从右端入队,从左端出队.为了节省空间实现上可以采用循环队列</p>
<h3 id="链表Linked-List"><a href="#链表Linked-List" class="headerlink" title="链表Linked List"></a>链表Linked List</h3><p>(这几个都感觉没什么好说的)</p>
<p>讲一下<strong>邻接表(Adjacency List)</strong>吧,它可以看成是”带有索引数组的多个数据链表”,这种所引就是链表的表头,表头又构成了一个表头(headers)数组</p>
<p>存图常用邻接表或是邻接矩阵(Adjacency Matrix)</p>
<p>邻接表</p>
<figure class="hljs highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> num_edge=<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> ne,to,dis;<br>&#125;edge[maxm];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> to,<span class="hljs-keyword">int</span> dis)</span></span>&#123;<br>    edge[++num_edge].ne=h[f];<br>    edge[num_edge].to=to;<br>    edge[num_edge].dis=dis;<br>    h[f]=num_edge;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字典树Trie"><a href="#字典树Trie" class="headerlink" title="字典树Trie"></a>字典树Trie</h3><p>字典树是一种用于实现字符串快速检索的多叉树结构，其节点都拥有字符指针.</p>
<p>“Trie is an efficient information <strong>reTrieval</strong> data structure.Using trie,search complexities can be brought too optimal limit(O(M),M is key length).However the penalty is on Trie storage requirements.”</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> trie[maxn][<span class="hljs-number">27</span>],tot=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> end[maxn][<span class="hljs-number">27</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t=tot,x;<br>    <span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        x=str[i]-<span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span>(trie[t][x]==<span class="hljs-number">0</span>)trie[t][x]=++tot;<br>        t=trie[t][x];<br>    &#125;<br>    end[t][x]=<span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Match_Ok</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t=tot,x;<br>    <span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        x=str[i]-<span class="hljs-string">'a'</span>;<br>        t=trie[t][x];<br>        <span class="hljs-keyword">if</span>(!t)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> end[t][x];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二叉堆Binary-Heap"><a href="#二叉堆Binary-Heap" class="headerlink" title="二叉堆Binary Heap"></a>二叉堆Binary Heap</h3><p>二叉堆是一颗满足堆性质的完全二叉树.根据排序方式可以分为<strong>大根堆(Max-Heap)</strong>和<strong>小根堆(Min-Heap)</strong></p>
<p>对于大根堆,任意一个非根节点的权值都小于等于其父节点的权值;小根堆则反之</p>
<p>“A binary heap is a complete binary tree which satisfies the heap ordering property.The ordering can be one of two types:the min-heap property and the max-heap property.The value of each node of the max-heap is less than or equal to the value of its parent,with the maximum-value element at the root”</p>
<p>来源:<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html" target="_blank" rel="noopener">cs.cmu.edu</a></p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> heap[maxn],n;<span class="hljs-comment">//max-heap</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up_modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(heap[p]&gt;heap[p&gt;&gt;<span class="hljs-number">1</span>])&#123;<br>            swap(heap[p],heap[p&gt;&gt;<span class="hljs-number">1</span>]);<br>            p=p&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    heap[++n]=val;<br>    up(n);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> s=p&lt;&lt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(s&lt;=n)&#123;<br>        <span class="hljs-keyword">if</span>(s&lt;n&amp;&amp;heap[s]&lt;heap[s+<span class="hljs-number">1</span>])s++;<span class="hljs-comment">//choost the maximum one of the two sons</span><br>        <span class="hljs-keyword">if</span>(heap[s]&gt;heap[p])&#123;<br>            swap(heap[s],heap[p]);<br>            p=s,s=s&lt;&lt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">extract_top</span><span class="hljs-params">()</span></span>&#123;<br>    heap[<span class="hljs-number">1</span>]=heap[n--];<br>    down(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线段树Segment-Tree"><a href="#线段树Segment-Tree" class="headerlink" title="线段树Segment Tree"></a>线段树Segment Tree</h3><p>咕</p>
<h2 id="图论Graph-Theory"><a href="#图论Graph-Theory" class="headerlink" title="图论Graph Theory"></a>图论Graph Theory</h2><h3 id="Dijkstra算法Dijkstra-Algorithm"><a href="#Dijkstra算法Dijkstra-Algorithm" class="headerlink" title="Dijkstra算法Dijkstra Algorithm"></a>Dijkstra算法Dijkstra Algorithm</h3><p>DIjkstra算法是为了解决<strong>单源最短路径问题(Single Source Shortest Path,SSSP)</strong>的，简单来说，就是求原点到其它所有点(vertex pl.vertices)的最短路(shortest path)</p>
<p>它是基于一个贪心思想,要求所有边都是非负的.大致就是不断拓展一颗最短路生成树</p>
<p>“Dijkstra’s algorithm is very similar to Prim’s algorithm for <strong>minimum spanning tree(MST)</strong>.Like Prim’s MST,we generate a SPT(shortest path tree) with given source as root.We maintain two sets,one set contain vertices included in the shortest path tre,other set includes vertices not yet included in shortest path tree.At every step,we find a vertex which is in the other set and has a mimnum distance from the source.”</p>
<p>来源:<a href="https://www.google.com/amp/s/www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/amp/" target="_blank" rel="noopener">geeksforgeeks.org</a></p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ri register int </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id,d;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> Vertex &amp; a)<span class="hljs-keyword">const</span>&#123;<br>        <span class="hljs-keyword">return</span> d&gt;a.d;<br>    &#125;<br>    Vertex()&#123;;&#125;<br>    Vertex(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;id=x,d=y;&#125;<br>&#125;;<br>priority_queue &lt;Vertex&gt; q;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> to,<span class="hljs-keyword">int</span> dis)</span></span>&#123;<br>    edge[++num_edge].ne=h[f];<br>    edge[num_edge].to=to;<br>    edge[num_edge].dis=dis;<br>    h[f]=num_edge;<br>&#125;<br><span class="hljs-keyword">int</span> dis[maxn];<br><span class="hljs-keyword">bool</span> vis[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        dis[i]=INF,vis[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    q.push(Vertex(s,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(q.size())&#123;<br>        u=q.top().id,w=q.top().d;<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(vis[u])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(ri i=h[u];i;i=edge[i].ne)&#123;<br>            v=edge[i].to;<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>                dis[v]=dis[u]+w;<br>                q.push(Vertex(v,dis[v]))<br>            &#125;<br>        &#125;<br>        vis[u]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(ri i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dis[i]);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA"><a href="#Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA" class="headerlink" title="Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA"></a>Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA</h3><p>忽然发现ddl干不完了,因此介绍咕了</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dis[i]=INF,vis[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>,vis[s]=<span class="hljs-number">1</span>;<br>    q.push(s);<br>    <span class="hljs-keyword">while</span>(q.size())&#123;<br>        u=q.top();q.pop();<br>        vis[u]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[u];i;i=edge[i].ne)&#123;<br>            v=edge[i].to,w=edge[i].dis;<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>                dis[v]=dis[u]+w;<br>                <span class="hljs-keyword">if</span>(!dis[v])&#123;q.push(v);dis[v]=<span class="hljs-number">1</span>;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dis[i]);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Floyd算法Floyd-Warshall-Algorithm"><a href="#Floyd算法Floyd-Warshall-Algorithm" class="headerlink" title="Floyd算法Floyd Warshall Algorithm"></a>Floyd算法Floyd Warshall Algorithm</h3><p>Floyd算法是基于动态规划思想来解决任意两点之间最短路径(All Pairs Shortest Path problem,APSP)的算法</p>
<p>亦可用于可传递的关系(传递闭包),这个也先挖坑吧</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(d));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dis[i][i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);<br>    dis[x][y]=min(dis[x][y],z);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Kruskal算法Kruskal-Algorithm"><a href="#Kruskal算法Kruskal-Algorithm" class="headerlink" title="Kruskal算法Kruskal Algorithm"></a>Kruskal算法Kruskal Algorithm</h3><p>Kruskal算法是求出一张给定联通边带权无向图的最小生成树算法.那么什么是最小生成树?</p>
<p>“Given a connected and undirected graph, a <em>spanning tree</em> of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. A <em>minimum spanning tree (MST)</em> or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.”</p>
<p>来源:<a href="https://www.geeksforgeeks.org/?p=26604" target="_blank" rel="noopener">Geeksforgeeks</a> 强烈安利这个英文网站,写的浅显易懂而且最重要的是,<strong>it is not blocked</strong></p>
<p>Kruskal算法维护无向图的最小生成森林,每次在连接两个森林的边中找一条权值最小的将两个森林连起来.对于连通性我们使用并查集维护</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u,v,dis;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> Edge &amp; a)<span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> dis&lt;a.dis;<br>    &#125;<br>&#125;edge[maxm];<br><span class="hljs-keyword">int</span> fa[maxn];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x]!=x)fa[x]=get(fa[x]);<br>    <span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> u,v,w,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].dis);<br>	&#125;<br>    sort(edge+<span class="hljs-number">1</span>,edge+<span class="hljs-number">1</span>+m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    	u=edge[i].u,v=edge[i].v;<br>        u=get(u),v=get(v);<br>        <span class="hljs-keyword">if</span>(u!=v)&#123;<br>            fa[u]=v;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="树链剖分Heavy-Light-Decomposition"><a href="#树链剖分Heavy-Light-Decomposition" class="headerlink" title="树链剖分Heavy Light Decomposition"></a>树链剖分Heavy Light Decomposition</h3><p>树链剖分是用来解决一类树上问题的,可以将树上的操作转化为序列上的操作,同时使用数据结构维护可以使其复杂度更优,根据链剖方式可分为重链剖分和长链剖分等,这里介绍重链剖分</p>
<p>由于重链数量级是$log N$的,线段树时间复杂度是$log N$,总时间复杂度是$log^2 N$</p>
<p>还可以同时求LCA,但是操作时有许多细节需要注意,尤其是<code>dfn[]</code>和<code>rnk[]</code></p>
<p>找它的英文找了好久终于找到了,就是<strong>Heavy Light Decomposition</strong></p>
<p>“Suppose we have <strong>an unbalanced tree (not necessarily a Binary Tree) of n nodes</strong>, and we have to perform operations on the tree to answer a number of queries, each can be of one of the two types:</p>
<ol>
<li><strong>change(a, b)</strong>: Update weight of the ath edge to b.</li>
<li><strong>maxEdge(a, b)</strong>: Print the maximum edge weight on the path from node a to node b. For example maxEdge(5, 10) should print 25.</li>
</ol>
<p>“</p>
<p>来源:<a href="https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/" target="_blank" rel="noopener">geeksforgeeks</a></p>
<p>但是感觉<a href="https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/" target="_blank" rel="noopener">geeksforgeeks</a>上的介绍写得并不是很好…就不贴了.写一点自己口胡的工地英文</p>
<p>To perform two operations in a more efficient time complexity,we can first find out the heavy son of all nodes.We call a node is <strong>heavy</strong> only when its <strong>size</strong>(the number of nodes in its subtree) is larger than any of its siblings.We can make it by one DFS. Then we connects all the heavy-son node and we get several <strong>heavy-son chains</strong> and <strong>light-son chains</strong>.And if we want to perform two operations on the path of two nodes,we can perform operations on the segment tree built from the heavy-son chains along the path until we reach LCA.</p>
<p>Since it takes O($logN$) to perform operations on segment tree,apparently the complexity depends on the number of light-son chains.We can prove that it is no more than $log N$ along the path from one node to the tree root.,because when we meet one light-son chain,the number of nodes in his father’s subtree is reduced by at least half.</p>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fa[maxn],dfn[maxn],rnk[maxn]; <br><span class="hljs-keyword">int</span> w[maxn],dep[maxn],top[maxn],son[maxn],size[maxn];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> v;size[now]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[now];i;i=edge[i].to)&#123;<br>        v=edge[i].to;<br>        <span class="hljs-keyword">if</span>(v==fa[now])<span class="hljs-keyword">continue</span>;<br>        fa[v]=now,dep[v]=dep[now]+<span class="hljs-number">1</span>;<br>        dfs_1(v);<br>        size[now]+=size[v];<br>        <span class="hljs-keyword">if</span>(!son[now]||size[v]&gt;size[son[now]])son[now]=v;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> v;<br>    top[now]=t,dfn[now]=++cnt,rnk[cnt]=now;<br>    <span class="hljs-keyword">if</span>(!son[now])<span class="hljs-keyword">return</span> ;<br>    dfs_2(son[now],t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=h[now];i;i=edge[i].ne)&#123;<br>        v=edge[i].to;<br>        <span class="hljs-keyword">if</span>(v==son[now]||v==fa[now])<span class="hljs-keyword">continue</span>;<br>        dfs_2(v,v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">int</span> L,R;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation_on_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<br>        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);<br>        L=dfn[top[x]],R=dfn[x];<br>        operation_on_segmenttree(L,R);<br>        x=fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[x]&gt;dfn[y])swap(x,y);<span class="hljs-comment">//x is the LCA</span><br>    L=dfn[x],R=dfn[y];<br>    operation_on_segmenttree(L,R);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operation_on_subtree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    L=dfn[x],R=dfn[x]+size[x]<span class="hljs-number">-1</span>;<br>    operation_on_segmenttree(L,R);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="动态规划Dynamic-Programming"><a href="#动态规划Dynamic-Programming" class="headerlink" title="动态规划Dynamic Programming"></a>动态规划Dynamic Programming</h2><p>估计要咕了</p>
<p>问题具有以下两个性质时,可以用动态规划</p>
<p><strong>1) Overlapping Subproblems</strong>重叠子问题</p>
<p><strong>2) Optimal Substructure</strong>最优子结构</p>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/SM2/" rel="tag"><i class="fas fa-tags"></i>SM2</a>
        
        <a class="post-tag button" href="/tags/模板/" rel="tag"><i class="fas fa-tags"></i>模板</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2019/05/09/数学知识小结-1/" rel="next" title="数学知识小结#1"><i class="fas fa-angle-left"></i><span class="nav-title">数学知识小结#1</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2019/05/27/23rd江西省SM2项目RyeCatcher面试经历/" rel="prev" title="23rd江西省SM2项目RyeCatcher面试经历"><span class="nav-title">23rd江西省SM2项目RyeCatcher面试经历</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div class="commentjs" id="comment-thread"></div>
  <link rel="stylesheet" href="/css/commentjs.css">
  <script defer type="text/javascript" src="/js/marked.min.js"></script>
  <script defer type="text/javascript" src="/js/timeago.min.js"></script>
  <script defer type="text/javascript" src="/js/highlight.min.js"></script>
  <script defer type="text/javascript" src="/js/commentjs.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    getComments({
      "type": "github",
      "user": "Rye-Catcher",
      "repo": "Rye-Catcher.github.io",
      "client_id": "4c6c0291b3cb182b3186",
      "client_secret": "921158f9b8df233286104390fd95eb8ebde38fd4",
      "no_comment": "这个页面还没有评论，现在就去评论吧！",
      "go_to_comment": "去评论",
      "issue_title": "省选前模板复习",
      "btn_class": "button",
      "comments_target": "#comment-thread"
    });
    marked.setOptions({
      "highlight": function (code, lang) {
        return hljs.highlightAuto(code).value;
      }
    });
    function mark() {
      var markdowns = document.getElementsByClassName("markdown");
      for (var i = 0; i < markdowns.length; ++i){
        if (markdowns[i].innerHTML) {
          markdowns[i].innerHTML = marked(markdowns[i].innerHTML);
        }
      }
    }
    window.addEventListener("DOMContentLoaded", mark, false);
    window.addEventListener("load", mark, false);
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="https://s1.ax1x.com/2018/08/11/PcnGYn.png" alt="Rye_Catcher">
  
  <h1 class="author-name">Rye_Catcher</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">129</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">16</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">84</a></div>
    </div>
    
    
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#PREFACE"><span class="toc-text">PREFACE</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#数学知识"><span class="toc-text">数学知识</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#KMP算法Knuth-Morris-Pratt-Algorithm"><span class="toc-text">KMP算法Knuth-Morris-Pratt Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#哈希Hash-Function"><span class="toc-text">哈希Hash Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#数据结构Data-Structure"><span class="toc-text">数据结构Data Structure</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#栈Stack"><span class="toc-text">栈Stack</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#队列Queue"><span class="toc-text">队列Queue</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#链表Linked-List"><span class="toc-text">链表Linked List</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#字典树Trie"><span class="toc-text">字典树Trie</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#二叉堆Binary-Heap"><span class="toc-text">二叉堆Binary Heap</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#线段树Segment-Tree"><span class="toc-text">线段树Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#图论Graph-Theory"><span class="toc-text">图论Graph Theory</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Dijkstra算法Dijkstra-Algorithm"><span class="toc-text">Dijkstra算法Dijkstra Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Bellman-Ford算法和SPFA算法Bellman-Ford-Algorithm-And-SPFA"><span class="toc-text">Bellman-Ford算法和SPFA算法Bellman-Ford Algorithm And SPFA</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Floyd算法Floyd-Warshall-Algorithm"><span class="toc-text">Floyd算法Floyd Warshall Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Kruskal算法Kruskal-Algorithm"><span class="toc-text">Kruskal算法Kruskal Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#树链剖分Heavy-Light-Decomposition"><span class="toc-text">树链剖分Heavy Light Decomposition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#动态规划Dynamic-Programming"><span class="toc-text">动态规划Dynamic Programming</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:2427367956@qq.com" target="_blank">Mail</a></li>
        
        <li><i class="fas fa-code"></i><a href="https://www.luogu.org/space/show?uid=61382" target="_blank">Luogu</a></li>
        
        <li><i class="fas fa-book"></i><a href="https://www.zhihu.com/people/ryecatcher-16/activities" target="_blank">Zhihu</a></li>
        
        <li><i class="fas fa-coffee"></i><a href="https://www.douban.com/people/178862274/" target="_blank">Douban</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/Rye-Catcher" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://www.cnblogs.com/Rye-Catcher/" target="_blank">旧博客</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://www.cnblogs.com/xxzh/" target="_blank">巨佬同学-星星之火-JX</a></li>
        
        <li><i class="fas fa-link"></i><a href="http://www.wjyyy.top/" target="_blank">wjyyy-HB</a></li>
        
        <li><i class="fas fa-link"></i><a href="http://www.cnblogs.com/ppprseter/" target="_blank">Dew-HB</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://oi.logey.cn/" target="_blank">Logey-SD</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://ouuan.github.io/" target="_blank">Ouuan-HB</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://acfunction.github.io/" target="_blank">AcFunciton-BJ</a></li>
        
        <li><i class="fas fa-link"></i><a href="http://bubbleioa.top/" target="_blank">冒泡ioa-JX</a></li>
        
        <li><i class="fas fa-link"></i><a href="http://cnblogs.com/huyufeifei/" target="_blank">huyufeifei</a></li>
        
        <li><i class="fas fa-link"></i><a href="http://mayflyyh.com" target="_blank">额冻豆腐</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">Rye_Catcher</span><span class="year"><i class="far fa-copyright"></i>2018 - 2019</span><span class="creative-commons"><i class="fab fa-creative-commons"></i><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a></span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
